\documentclass[12pt]{article}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{tikz}
\pagestyle{fancy}
\fancyhf{}
\rhead{FECP5 45/45}
\lhead{1Z0-808 Mock Exam}
\rfoot{\thepage}

\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection}{1em}{}

\title{\textbf{1Z0-808 Mock Exam}}
\author{ExamId: 101 \\ Items: 56 \\ Dificulty: HARD}
\date{\today}

\begin{document}

\maketitle
\newpage\begin{enumerate}[label=(\arabic*)]
\item (questionId: 102228) What is the result of attempting to compile and run the Test class?\n\begin{verbatim}
interface I1 {
    default void go() { System.out.println("I1"); }
}
interface I2 {
    default void go() { System.out.println("I2"); }
}
class C1 implements I1, I2 {
    public void go() {
        I1.super.go();
    }
}
public class Test {
    public static void main(String[] args) {
        new C1().go();
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) A compile-time error at `class C1`.

\item 1) The code compiles and prints "I1".

\item 2) The code compiles and prints "I2".

\item 3) A compile-time error at `I1.super.go();` because `super` can only be used with classes.

\end{itemize}
\item (questionId: 103024) What is the result of compiling this code?
\begin{verbatim}
import java.io.*;

public class CatchOrder {
    public void process() {
        try {
            if (System.currentTimeMillis() % 2 == 0) {
                throw new IOException();
            } else {
                throw new FileNotFoundException();
            }
        } catch (IOException e) { // line X
            System.out.println("IO");
        } catch (FileNotFoundException e) { // line Y
            System.out.println("File Not Found");
        }
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) Compilation succeeds.

\item 1) Compilation fails at line X.

\item 2) Compilation fails at line Y.

\item 3) Compilation fails at both line X and line Y.

\end{itemize}
\item (questionId: 100124) An abstract class is defined as follows:
\begin{verbatim}
abstract class AbstractRunner {
    public static void main(String[] args) {
        System.out.println("Running from abstract class");
    }
}
\end{verbatim}
What is the outcome of compiling and executing `java AbstractRunner`?
Choose the most correct answer. 
\begin{itemize}
\item 0) Compilation fails.

\item 1) An `InstantiationException` is thrown at runtime.

\item 2) An `AbstractMethodError` is thrown at runtime.

\item 3) It compiles and runs successfully, printing the message.

\end{itemize}
\item (questionId: 100921) What is the result of attempting to compile and run the following class?\n\begin{verbatim}
public class SwitchCaseConstant {
    public static void main(String[] args) {
        final int a = 1;
        final int b;
        b = 2;
        int x = 0;
        switch (x) {
            case a: // case 1
                System.out.print("A");
            case b: // case 2
                System.out.print("B");
        }
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) It prints `A`.

\item 1) It prints `B`.

\item 2) It prints `AB`.

\item 3) A compilation error occurs.

\end{itemize}
\item (questionId: 103356) What is the result of executing the following code? This question tests the case-sensitivity and symbol correctness of formatter patterns.
\begin{verbatim}
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class PatternCaseTest {
    public static void main(String[] args) {
        String dateStr = "2-8-2025";
        DateTimeFormatter f = DateTimeFormatter.ofPattern("d-m-yyyy");
        LocalDate date = LocalDate.parse(dateStr, f);
        System.out.println(date);
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `2025-08-02`

\item 1) `2025-02-08`

\item 2) The code does not compile.

\item 3) A `DateTimeParseException` is thrown.

\end{itemize}
\item (questionId: 100229) Given the file `pkg/A.java`:
\begin{verbatim}
package pkg;
public class A {
    public void print() { System.out.println("A"); }
}
\end{verbatim}
And the file `B.java`:
\begin{verbatim}
import pkg.A;
public class B {
    public static void main(String[] args) {
        A a = new A();
        a.print();
    }
}
\end{verbatim}
From the project root, which command sequences will compile and run the code successfully? (Assume Linux/macOS). (Choose all that apply)
Choose all the correct answer.\begin{itemize}
\item 0) `javac pkg/A.java B.java; java B`

\item 1) `javac -d . pkg/A.java B.java; java B`

\item 2) `javac B.java; java B` (assuming `pkg/A.class` already exists)

\item 3) `javac pkg/A.java B.java; java -cp . B`

\item 4) `javac B.java; java -cp . B` (assuming `pkg/A.class` does not exist)

\end{itemize}
\item (questionId: 101225) Which of the following code snippets will result in a compilation error? (Choose all that apply)
Choose all the correct answer.\begin{itemize}
\item 0) \begin{verbatim}public enum E1 { A, B; private E1() {} }\end{verbatim}

\item 1) \begin{verbatim}public enum E2 { C, D; protected E2() {} }\end{verbatim}

\item 2) \begin{verbatim}public enum E3 { E, F; E3() {} }\end{verbatim}

\item 3) \begin{verbatim}public enum E4 { G, H; public E4() {} }\end{verbatim}

\end{itemize}
\item (questionId: 100523) Examine the following code. What will be the outcome?
\begin{verbatim}
final int i = 10;
byte b = i;
System.out.println(b);
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) The code fails to compile because a cast `(byte)` is required.

\item 1) The code compiles and prints `10`.

\item 2) The code fails to compile because `i` is final and cannot be assigned.

\item 3) The code compiles but throws a runtime exception.

\end{itemize}
\item (questionId: 100028) You are in the directory \verb|/root|. You have the following files:
\verb|/root/com/example/App.java|
\verb|/root/lib/helper.jar|
The class \verb|App| depends on a class inside \verb|helper.jar|. Which command(s) will successfully compile \verb|App.java|? (Choose all that apply)
Choose all the correct answer.\begin{itemize}
\item 0) \verb|javac -cp lib/helper.jar com/example/App.java|

\item 1) \verb|javac -classpath lib/helper.jar com/example/App.java|

\item 2) \verb|javac com/example/App.java -cp lib/helper.jar|

\item 3) \verb|javac -cp lib/helper.jar;com/example/App.java|

\item 4) \verb|javac -d . -cp lib/helper.jar com/example/App.java|

\end{itemize}
\item (questionId: 103453) Consider an interface with a static method (a Java 8 feature). What is the result of this code?
\begin{verbatim}
// File: I.java
public interface I {
    static void run() { System.out.println("I"); }
}

// File: C.java
public class C {
    public static void run() { System.out.println("C"); }
}

// File: Main.java
import static I.*;
import static C.*;

public class Main {
    public static void main(String[] args) {
        run();
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) It prints `I`.

\item 1) It prints `C`.

\item 2) The code fails to compile due to ambiguity.

\item 3) The code fails to compile because you cannot statically import methods from an interface.

\end{itemize}
\item (questionId: 103650) What is the output of the following code? This question tests `final` parameters.
\begin{verbatim}
class Box { public int size; }

public class FinalParamTest {
    public static void modify(final Box b) {
        b.size = 100;
        // b = new Box(); // This line is commented out
    }

    public static void main(String[] args) {
        Box box = new Box();
        box.size = 10;
        modify(box);
        System.out.println(box.size);
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `10`

\item 1) `100`

\item 2) The code fails to compile because a method cannot modify a `final` parameter.

\item 3) The code fails to compile for another reason.

\end{itemize}
\item (questionId: 100024) What is the result of compiling and running the following class?
\begin{verbatim}
public class Test {
    static {
        System.out.print("Static block. ");
    }

    public static void main(String[] args) {
        System.out.print("Main method.");
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) Main method.

\item 1) Static block. Main method.

\item 2) Main method. Static block.

\item 3) Compilation fails.

\end{itemize}
\item (questionId: 103124) What is the result of attempting to compile this code?
\begin{verbatim}
class Box implements AutoCloseable {
    private void close() throws Exception {}
}
public class TestPrivateClose {
    public static void main(String[] args) {
        try (Box b = new Box()) {
            // ...
        }
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) The code compiles but fails at runtime with an `IllegalAccessException`.

\item 1) A compilation error occurs because the `close()` method is private.

\item 2) The code compiles and runs without issue, as the JVM can access the private method.

\item 3) A compilation error occurs because the `main` method doesn't handle the `Exception` from `close()`.

\end{itemize}
\item (questionId: 102025) Which line causes a compilation error?
\begin{verbatim}
class T1 {
    T1() { super(); }
    T1(int i) { this(); }
}
class T2 extends T1 {
    T2() { super(5); }
    T2(int i) { this(); }
    T2(String s) {}
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `T1() { super(); }`

\item 1) `T1(int i) { this(); }`

\item 2) `T2() { super(5); }`

\item 3) `T2(int i) { this(); }`

\item 4) `T2(String s) {}`

\end{itemize}
\item (questionId: 101521) What is the output of the following code?\n\begin{verbatim}
public class Chain {
    private int value;

    public Chain() {
        this(5);
        System.out.print("A");
    }

    public Chain(int value) {
        this(value, "X");
        System.out.print("B");
        this.value += value;
    }

    public Chain(int value, String s) {
        System.out.print(s);
        this.value = value;
    }

    public static void main(String[] args) {
        Chain c = new Chain();
        System.out.print(c.value);
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) XBA5

\item 1) ABX10

\item 2) XBA10

\item 3) The code fails to compile.

\end{itemize}
\item (questionId: 101721) What is the output of the following code? This question tests method hiding.\n\begin{verbatim}
class Animal {
    static void eat() { System.out.println("Animal eats"); }
}
class Dog extends Animal {
    static void eat() { System.out.println("Dog eats"); }
}
public class Test {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.eat();
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) Animal eats

\item 1) Dog eats

\item 2) The code fails to compile.

\item 3) A runtime exception is thrown.

\end{itemize}
\item (questionId: 101326) Which of the following code snippets will result in `s2` referring to the same object as `s1` in the string pool? (Choose all that apply)
\begin{verbatim}
String s1 = "Test";
\end{verbatim}
Choose all the correct answer.\begin{itemize}
\item 0) `String s2 = "Test";`

\item 1) `String s2 = new String("Test");`

\item 2) `String s2 = new String("Test").intern();`

\item 3) `String s2 = "Te" + "st";`

\end{itemize}
\item (questionId: 100629) What is the output of the code?\n\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        Integer a = 10;
        Integer b = 10;
        Integer c = a + b;
        Integer d = 20;
        System.out.println(c == d);
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) \verb|true|

\item 1) \verb|false|

\item 2) Compilation fails.

\item 3) An exception is thrown at runtime.

\end{itemize}
\item (questionId: 101524) What is the output of the following code?\n\begin{verbatim}
class Wallet {
    public int cash;
}

public class Thief {
    public static void main(String[] args) {
        Wallet w = new Wallet();
        w.cash = 100;
        steal(w);
        System.out.println(w.cash);
    }

    public static void steal(Wallet victimWallet) {
        victimWallet.cash -= 50;
        victimWallet = new Wallet(); // Thief gets a new wallet
        victimWallet.cash = 10;
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) 100

\item 1) 50

\item 2) 10

\item 3) 0

\end{itemize}
\item (questionId: 100428) What happens when this code is compiled and run?
\begin{verbatim}
System.out.println(10 / 0);
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) It fails to compile.

\item 1) It prints `Infinity`.

\item 2) It prints `NaN`.

\item 3) It compiles but throws an `ArithmeticException` at runtime.

\end{itemize}
\item (questionId: 101823) Which of these statements are true regarding Java's memory management and garbage collection? (Choose all that apply)
Choose all the correct answer.\begin{itemize}
\item 0) Objects are stored on the heap, while object references are typically stored on the stack.

\item 1) The `finalize()` method is a reliable mechanism for cleaning up critical resources like database connections.

\item 2) An 'island of isolation' refers to a group of objects that reference each other but have no external reachable references, making them eligible for GC.

\item 3) Generational garbage collectors divide the heap into young and old generations to improve efficiency, assuming most objects die young.

\item 4) Calling `System.exit(0)` will trigger garbage collection and finalization for all live objects before the JVM shuts down.

\end{itemize}
\item (questionId: 101021) What is the output of this code with labeled statements?\n\begin{verbatim}
public class LabeledBreak {
    public static void main(String[] args) {
        outer:
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (i == 1) {
                    break outer;
                }
                System.out.print(i + "" + j + " ");
            }
        }
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) 00 01 02 

\item 1) 00 01 02 20 21 22 

\item 2) 00 01 02 10 11 12 20 21 22 

\item 3) The code does not compile.

\end{itemize}
\item (questionId: 100224) You execute a program with `java -jar myapp.jar`. The manifest file inside `myapp.jar` contains the line `Class-Path: lib/utils.jar`. The JVM will:
Choose the most correct answer. 
\begin{itemize}
\item 0) Ignore the `Class-Path` attribute in the manifest.

\item 1) Automatically add `lib/utils.jar` to the classpath.

\item 2) Throw an error because `Class-Path` is not a valid manifest attribute.

\item 3) Only use `lib/utils.jar` if the `-cp` flag is also specified.

\end{itemize}
\item (questionId: 102323) Examine the following code. What is its result?\n\begin{verbatim}
public class Runner {
    public static void main(String[] args) {
        int y = 1;
        Runnable r = () -> {
            // Line 1
            System.out.println(y);
        };
        // Line 2
    }
}
\end{verbatim}
What happens if the statement `y = 2;` is placed at Line 2?
Choose the most correct answer. 
\begin{itemize}
\item 0) The code compiles and runs fine.

\item 1) The code fails to compile due to an error at Line 1 (`System.out.println(y);`).

\item 2) The code fails to compile due to an error at `y = 2;` because `y` is now effectively final.

\item 3) The code compiles but throws a runtime exception.

\end{itemize}
\item (questionId: 101421) What is the output of the following program?
\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder("Initial");
        reassign(sb);
        System.out.print(sb + ":");
        modify(sb);
        System.out.print(sb);
    }
    static void reassign(StringBuilder sb) {
        sb = new StringBuilder("New");
    }
    static void modify(StringBuilder sb) {
        sb.append("-Mod");
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `Initial:Initial-Mod`

\item 1) `New:New-Mod`

\item 2) `Initial:Initial`

\item 3) `New:Initial-Mod`

\end{itemize}
\item (questionId: 102625) Due to type erasure, what does the following generic class effectively become after compilation?\begin{verbatim}
public class Node<T extends Comparable<T>> {
    private T data;
    private Node<T> next;
    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }
    public T getData() { return data; }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) \begin{verbatim}public class Node {
    private Comparable data;
    private Node next;
    // ... constructor and methods with casts
}\end{verbatim}

\item 1) \begin{verbatim}public class Node {
    private Object data;
    private Node next;
    // ... constructor and methods with casts
}\end{verbatim}

\item 2) \begin{verbatim}public class Node<Comparable> {
    private Comparable data;
    private Node<Comparable> next;
    // ...
}\end{verbatim}

\item 3) The generic information is retained fully in the bytecode.

\end{itemize}
\item (questionId: 101320) What is the output of the following code?
\begin{verbatim}
final String f = "Ja";
String s1 = f + "va";
String s2 = "Java";
System.out.println(s1 == s2);
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `true`

\item 1) `false`

\item 2) The code does not compile because `f` is `final`.

\item 3) An exception is thrown at runtime.

\end{itemize}
\item (questionId: 100426) What is printed to the console by the following code?
\begin{verbatim}
int value = 'a' + 'b';
System.out.println(value);
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `ab`

\item 1) `195`

\item 2) The code fails to compile.

\item 3) `9798`

\end{itemize}
\item (questionId: 100321) What is the result of attempting to compile the following code?
\begin{verbatim}
public class NestedComment {
    /*
     * This is an outer comment.
     * /* This is a nested comment. */
     * The outer comment ends here.
     */
    public static void main(String[] args) {
        System.out.println("Hello");
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) Compilation is successful, and the program prints "Hello".

\item 1) Compilation fails due to an unclosed comment.

\item 2) Compilation is successful, but a warning is issued about nested comments.

\item 3) Compilation fails due to illegal syntax inside a comment.

\end{itemize}
\item (questionId: 102125) What is the output of the following code?\n\begin{verbatim}
class Parent {
    void process(Object o) {
        System.out.println("Parent-Object");
    }
}
class Child extends Parent {
    @Override
    void process(Object o) {
        System.out.println("Child-Object");
    }
    void process(String s) {
        System.out.println("Child-String");
    }
}
public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        p.process("test");
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) Parent-Object

\item 1) Child-Object

\item 2) Child-String

\item 3) The code fails to compile.

\end{itemize}
\item (questionId: 102424) Which of the following statements are true? (Choose all that apply)
Choose all the correct answer.\begin{itemize}
\item 0) \verb|int[] x, y[];| declares \verb|x| as a 1D array and \verb|y| as a 2D array.

\item 1) An array's size can be changed after it has been created.

\item 2) \verb|new int[0]| creates an array of size 0.

\item 3) An \verb|ArrayStoreException| is a checked exception.

\end{itemize}
\item (questionId: 103226) What is the result of the following code?
\begin{verbatim}
import java.util.function.Function;

public class TrickyThis {
    private String value = "Enclosing";

    public Function<String, String> create() {
        return x -> this.value + ":" + x;
    }

    public static void main(String[] args) {
        TrickyThis t = new TrickyThis();
        System.out.println(t.create().apply("Lambda"));
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `Enclosing:Lambda`

\item 1) `Lambda:Enclosing`

\item 2) A compilation error occurs due to the use of `this`.

\item 3) A `NullPointerException` is thrown at runtime.

\end{itemize}
\item (questionId: 102525) Which code snippet demonstrates the correct way to create a generic `ArrayList` that can hold any subclass of `Number`?
Choose the most correct answer. 
\begin{itemize}
\item 0) \verb|List<? super Number> list = new ArrayList<Integer>();|

\item 1) \verb|List<? extends Number> list = new ArrayList<Integer>();|

\item 2) \verb|List<T extends Number> list = new ArrayList<T>();|

\item 3) \verb|List<Number> list = new ArrayList<Integer>();|

\end{itemize}
\item (questionId: 102822) What is the outcome of compiling and running the following code?
\begin{verbatim}
public class Test {
    static {
        if (true) {
            throw new NullPointerException("Error in static block");
        }
    }
    public static void main(String[] args) {
        System.out.println("Hello");
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) A `NullPointerException` is caught by the JVM and `Hello` is printed.

\item 1) The program prints `Hello` and exits normally.

\item 2) An `ExceptionInInitializerError` is thrown, and the program terminates.

\item 3) A `NullPointerException` is thrown, and the program terminates.

\end{itemize}
\item (questionId: 103557) Which of the following method calls are ambiguous and will cause a compilation error? (Choose all that apply)
\begin{verbatim}
class Ambiguity {
    static void m(int a, long b) {} // M1
    static void m(long a, int b) {} // M2
    static void m(int... a) {}      // M3
    static void m(Number n) {}      // M4
    static void m(Object o) {}      // M5
}
\end{verbatim}
Choose all the correct answer.\begin{itemize}
\item 0) `Ambiguity.m(5, 10);`

\item 1) `Ambiguity.m(5L, 10L);`

\item 2) `Ambiguity.m(5);`

\item 3) `Ambiguity.m(new Integer(5));`

\item 4) `Ambiguity.m(null);`

\end{itemize}
\item (questionId: 101929) Examine the code:
\begin{verbatim}
public final class MyData {
    private final StringBuilder builder;

    public MyData(StringBuilder b) {
        this.builder = b;
    }

    public StringBuilder getBuilder() {
        return builder;
    }
}

// Main method in another class
StringBuilder sb = new StringBuilder("Initial");
MyData data = new MyData(sb);
sb.append(" Changed");
System.out.println(data.getBuilder());
\end{verbatim}
What is the output?
Choose the most correct answer. 
\begin{itemize}
\item 0) Initial

\item 1) Initial Changed

\item 2) A new `StringBuilder` object's string representation.

\item 3) Compilation fails because `final` fields cannot be assigned in a constructor.

\item 4) Compilation fails because `StringBuilder` is mutable.

\end{itemize}
\item (questionId: 100726) What is printed to the console?\n\begin{verbatim}
public class TrickyScope {
    static TrickyScope ts = new TrickyScope();
    static int val = 10;
    {
        // instance initializer
        val = 20;
    }

    public static void main(String[] args) {
        System.out.println(val);
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) 10

\item 1) 20

\item 2) 0

\item 3) Compilation fails.

\end{itemize}
\item (questionId: 101427) Given `StringBuilder sb = new StringBuilder("abcde");`. Which statements about its capacity are true? (Choose all that apply)
Choose all the correct answer.\begin{itemize}
\item 0) The initial capacity is 21 (5 for "abcde" + 16 default).

\item 1) `sb.trimToSize();` will likely change its capacity to 5.

\item 2) After `sb.append("fghijklmnopqrstuvwxyz");`, the capacity will be larger than its length.

\item 3) `sb.ensureCapacity(10);` will not change the capacity.

\end{itemize}
\item (questionId: 100728) Which statements about the following code are correct? (Choose all that apply)\n\begin{verbatim}
public class Outer {
    private String name = "Outer";

    class Inner {
        private String name = "Inner";

        void printNames() {
            String name = "Local";
            System.out.println(name);
            System.out.println(this.name);
            System.out.println(Outer.this.name);
        }
    }

    public static void main(String... args) {
        new Outer().new Inner().printNames();
    }
}
\end{verbatim}
Choose all the correct answer.\begin{itemize}
\item 0) The code will fail to compile.

\item 1) The output will be: Local

\item 2) The output will be: Local Inner Outer

\item 3) \verb|this.name| refers to the instance variable of the \verb|Inner| class.

\item 4) \verb|Outer.this.name| is used to access the instance variable of the enclosing \verb|Outer| class.

\end{itemize}
\item (questionId: 100121) What is the result of attempting to compile and run the following code?
\begin{verbatim}
public class TrickyMain {
    public static void main(String args) {
        System.out.println("Hello");
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) It compiles and runs, printing "Hello".

\item 1) It fails to compile because the `main` parameter is not an array.

\item 2) It compiles, but at runtime the JVM reports that `main` is not found.

\item 3) It compiles and runs, but `args` is null.

\end{itemize}
\item (questionId: 101127) Consider the following code. Which line causes a compilation error?\n\begin{verbatim}
label1: while (true) {      // Line 1
    int x = 0;               // Line 2
    label2: do {             // Line 3
        x++;                 // Line 4
        continue label1;     // Line 5
    } while(x < 5);          // Line 6
    break label2;            // Line 7
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) Line 3

\item 1) Line 5

\item 2) Line 7

\item 3) The code compiles without errors.

\end{itemize}
\item (questionId: 100628) Examine this code. What will be printed to the console?\n\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        Integer i1 = 10;
        Long l1 = 10L;
        
        System.out.println(i1.equals(l1));
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) \verb|true|

\item 1) \verb|false|

\item 2) The code does not compile.

\item 3) A runtime exception is thrown.

\end{itemize}
\item (questionId: 101822) What is the final value of `count` printed to the console?
\begin{verbatim}
public class GCCount {
    static int count = 0;
    int id;

    public GCCount(int id) { this.id = id; }

    public static void main(String[] args) {
        new GCCount(1);
        GCCount g2 = new GCCount(2);
        GCCount g3 = new GCCount(3);
        g2 = g3;
        new GCCount(4);
        g3 = null;
        // Point X
        System.gc();
        System.out.println(count);
    }

    @Override
    protected void finalize() {
        count++;
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) 0

\item 1) 2

\item 2) 3

\item 3) 4

\item 4) The output is not guaranteed.

\end{itemize}
\item (questionId: 101224) What is true about the serialization of enums?
Choose the most correct answer. 
\begin{itemize}
\item 0) Enums are not serializable by default and require implementing `java.io.Serializable` and defining a `serialVersionUID`.

\item 1) When an enum is deserialized, the constructor is called again to create a new instance.

\item 2) Java's serialization mechanism ensures that deserializing an enum constant will always return the pre-existing constant instance, thus preserving singleton identity.

\item 3) Deserializing an enum may result in a different object instance if the enum declaration has changed, causing `==` to fail.

\end{itemize}
\item (questionId: 101625) What is the result of attempting to compile and run the following code?\n\begin{verbatim}
abstract class Builder {
    Builder() { System.out.print("B"); }
}

public class House extends Builder {
    House() {
        // super() is implicitly called here
        System.out.print("H");
    }

    public static void main(String[] args) {
        new House();
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) The code fails to compile because an abstract class cannot have a constructor.

\item 1) The code compiles and prints "BH".

\item 2) The code compiles and prints "HB".

\item 3) The code fails to compile because `new Builder()` is not allowed.

\end{itemize}
\item (questionId: 100821) What is the final value of `a`?\n\begin{verbatim}
int a = 2;
a = a++ * a++;
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) 4

\item 1) 6

\item 2) 8

\item 3) 9

\end{itemize}
\item (questionId: 101723) What is the output of the following code? This question tests static initialization order.\n\begin{verbatim}
public class Init {
    static { a = b * 2; }
    static int a = 10;
    static int b = 5;
    static { a = b * 3; }

    public static void main(String[] args) {
        System.out.println(a);
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) 10

\item 1) 15

\item 2) 30

\item 3) The code fails to compile.

\end{itemize}
\item (questionId: 100929) What is true about the following code snippet? (Choose all that apply)\n\begin{verbatim}
public class Tricky {
    public static void main(String[] args) {
        boolean a = true, b = false, c = false;
        if ( a || (b=true) && (c=true) )
            ;
        System.out.println(a + " " + b + " " + c);
    }
}
\end{verbatim}
Choose all the correct answer.\begin{itemize}
\item 0) The output is `true false false`.

\item 1) The output is `true true true`.

\item 2) The variable `b` is assigned `true` during the evaluation of the `if` condition.

\item 3) The variable `c` is assigned `true` during the evaluation of the `if` condition.

\item 4) The code does not compile.

\end{itemize}
\item (questionId: 101629) Which statements correctly describe the complete order of initialization for an object `new Sub()` where `Sub extends Super`? (Choose all that apply)
Choose all the correct answer.\begin{itemize}
\item 0) Static initializers of `Super` run before static initializers of `Sub`.

\item 1) All instance initializers (both `Super` and `Sub`) run before any constructor code.

\item 2) The constructor body of `Super` runs before the instance initializers of `Sub`.

\item 3) The constructor body of `Sub` is the very last thing to run for the `Sub` object's initialization.

\item 4) Static initializers of `Sub` run before instance initializers of `Super`.

\item 5) Instance initializers of `Sub` run before the constructor body of `Sub`.

\end{itemize}
\item (questionId: 102921) What is the value returned by the method `check()`?
\begin{verbatim}
public class Test {
    public static int check() {
        try {
            return 1;
        } catch (Exception e) {
            return 2;
        } finally {
            return 3;
        }
    }
    public static void main(String[] args) {
        System.out.println(check());
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `1`

\item 1) `2`

\item 2) `3`

\item 3) The code does not compile.

\end{itemize}
\item (questionId: 102725) What is the output?
\begin{verbatim}
class Legacy {
    public int compareTo(Object o) { return 0; }
}
class Generic extends Legacy implements Comparable<Generic> {
}
// in a method
Comparable c = new Generic();
System.out.println(c.compareTo("test"));
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `0`

\item 1) A `ClassCastException` is thrown at runtime.

\item 2) The code does not compile.

\item 3) The output is unpredictable.

\end{itemize}
\item (questionId: 100528) What is the result of the following code snippet?
\begin{verbatim}
float f = (float) Double.POSITIVE_INFINITY;
int i = (int) f;
System.out.println(i);
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) `0`

\item 1) `-1`

\item 2) `2147483647`

\item 3) A runtime `ArithmeticException` is thrown.

\end{itemize}
\item (questionId: 100324) A class contains a method with the following Javadoc comment. What is the result of attempting to compile the source file containing this code?
\begin{verbatim}
/**
 * Processes a request.
 * @parameter name The name of the user.
 * @return The result of the processing.
 */
public String process(String name) { return "Processed: " + name; }
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) Compilation fails because `@parameter` is not a valid Javadoc tag.

\item 1) Compilation succeeds.

\item 2) Compilation succeeds, but the `javadoc` tool will fail to execute.

\item 3) Compilation fails with a warning about the unrecognized tag.

\end{itemize}
\item (questionId: 100826) What is the output of the following program?\n\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        int x = 5;
        boolean b1 = true;
        boolean b2 = false;
        if ((x == 4) && !b2 )
            System.out.print("1 ");
        System.out.print("2 ");
        if ((b2 = true) && b1 )
            System.out.print("3 ");
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) 2

\item 1) 2 3

\item 2) 1 2 3

\item 3) 1 2

\end{itemize}
\item (questionId: 101027) What is the final value of `count`?\n\begin{verbatim}
int count = 0;
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
        if (j == 2)
            continue;
        count++;
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) 25

\item 1) 20

\item 2) 15

\item 3) 10

\end{itemize}
\item (questionId: 101121) What is the result of attempting to compile and run this code?\n\begin{verbatim}
public class LabeledBlock {
    public static void main(String[] args) {
        int x = 5;
        myBlock: {
            if (x == 5) {
                break myBlock;
            }
            System.out.print("Inside");
        }
        System.out.print("Outside");
    }
}
\end{verbatim}
Choose the most correct answer. 
\begin{itemize}
\item 0) It prints `InsideOutside`.

\item 1) It prints `Outside`.

\item 2) It prints `Inside`.

\item 3) It fails to compile.

\end{itemize}

\end{enumerate}

\end{document}