\documentclass[12pt]{article}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{tikz}
\pagestyle{fancy}
\fancyhf{}
\rhead{FECP5 45/45}
\lhead{1Z0-808 Mock Exam Solution}
\rfoot{\thepage}

\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection}{1em}{}

\title{\textbf{1Z0-808 Mock Exam Solutions}}
\author{ExamId: 100}
\date{\today}

\begin{document}

\maketitle
\newpage\begin{enumerate}[label=(\arabic*)]
\item (questionId: 103207, topic: Lambda Expressions and Functional Interfaces) \\ 
What is the result of executing the following code?
\begin{verbatim}
import java.util.function.Predicate;

public class CheckString {
    public static void main(String[] args) {
        Predicate<String> p = (s) -> s.isEmpty();
        System.out.println(p.test(""));
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `true`
 \\ 
CORRECT - The code compiles and runs successfully. \verb|Predicate<String>| has the method \verb|boolean test(String s)|. The lambda implements this by calling the \verb|isEmpty()| method on the input string. When \verb|p.test("")| is called, \verb|"".isEmpty()| is executed, which returns \verb|true|.

\item 1) `false`
 \\ 
WRONG - The \verb|String.isEmpty()| method returns \verb|true| for a string of length 0, such as \verb|""|.

\item 2) A `NullPointerException` is thrown.
 \\ 
WRONG - A \verb|NullPointerException| would be thrown if the method were called with a \verb|null| argument (i.e., \verb|p.test(null)|), because the lambda would attempt to call \verb|null.isEmpty()|. However, it is called with an empty string object \verb|""|, which is not \verb|null|.

\item 3) The code does not compile.
 \\ 
WRONG - The code is valid. It correctly imports \verb|java.util.function.Predicate|, uses a valid lambda expression, and the method call is appropriate.

\end{itemize}
\item (questionId: 100507, topic: Type Conversion and Casting) \\ 
What is the value of `i` after this code is executed?
\begin{verbatim}
double d = 12.9;
int i = (int)d;
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) 12
 \\ 
RIGHT - When a floating-point value (like a `double`) is cast to an integer type (like `int`), the fractional part is truncated (i.e., simply cut off), not rounded. Therefore, `(int)12.9` evaluates to `12`.

\item 1) 13
 \\ 
WRONG - The value is truncated, not rounded up.

\item 2) 12.9
 \\ 
WRONG - An `int` cannot hold a fractional value.

\item 3) The code does not compile.
 \\ 
WRONG - The explicit cast `(int)` makes the code compile successfully.

\end{itemize}
\item (questionId: 101820, topic: Garbage Collection and Object Lifecycle) \\ 
What happens if an exception is thrown from within a `finalize()` method?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) The exception propagates to the `main` thread and terminates the application if not caught.
 \\ 
WRONG - The exception is handled by the GC's finalizer thread and is not propagated to other application threads.

\item 1) The garbage collector catches the exception, ignores it, and halts finalization for that object.
 \\ 
CORRECT - The finalization process is run by a special JVM thread. If an exception is thrown from a \verb|finalize()| method, that thread catches the exception, effectively ignoring it (it's not propagated), and halts the finalization for that specific object. The object is still considered 'finalized' and will be reclaimed by the GC later.

\item 2) The object is not garbage collected.
 \\ 
WRONG - The object has already been marked for collection and its finalizer has been run (or attempted to run). It will be garbage collected in a subsequent cycle.

\item 3) The JVM will shut down immediately.
 \\ 
WRONG - An exception in \verb|finalize()| does not cause the JVM to shut down.

\item 4) It causes a compilation error.
 \\ 
WRONG - The \verb|finalize()| method is declared with \verb|throws Throwable|, so throwing an exception from it is syntactically valid.

\end{itemize}
\item (questionId: 102816, topic: Exception Hierarchy and Types) \\ 
Which exception will be thrown by the following code?
\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        String[] array = {"a", "b"};
        System.out.println(array[getIdx()].length());
    }
    public static int getIdx() {
        return 2;
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `NullPointerException`
 \\ 
WRONG - A \verb|NullPointerException| would occur if \verb|array[getIdx()]| evaluated to \verb|null|, but the expression doesn't get that far.

\item 1) `ArrayIndexOutOfBoundsException`
 \\ 
RIGHT - In the expression \verb|array[getIdx()].length()|, Java must first evaluate the array index. The method \verb|getIdx()| is called and returns \verb|2|. Then, the array access \verb|array[2]| is attempted. Since the array's valid indices are 0 and 1, this immediately throws an \verb|ArrayIndexOutOfBoundsException|. The \verb|.length()| method is never called.

\item 2) `StringIndexOutOfBoundsException`
 \\ 
WRONG - This would be thrown if you tried to access a character at an invalid index within a \verb|String|, which doesn't happen here.

\item 3) No exception is thrown.
 \\ 
WRONG - An exception is definitely thrown.

\end{itemize}
\item (questionId: 100619, topic: Wrapper Classes and Autoboxing/Unboxing) \\ 
Which of these lines of code will compile successfully? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) \verb|Float f = 10.0;|
 \\ 
WRONG (Will not compile) - The literal \verb|10.0| is a \verb|double| by default. Java does not automatically narrow a \verb|double| to a \verb|float|, nor does it autobox a \verb|double| to a \verb|Float|. To fix this, you would need to use a float literal: \verb|Float f = 10.0f;|.

\item 1) \verb|Character c = 65;|
 \\ 
WRONG (Will not compile) - You cannot autobox a primitive \verb|int| literal like \verb|65| into a \verb|Character| reference. A \verb|Character| must be initialized with a \verb|char| literal (e.g., \verb|'A'|) or by an explicit cast (e.g., \verb|(char)65|).

\item 2) \verb|double d = new Double(10.5);|
 \\ 
CORRECT (Will compile) - This is a valid **unboxing** operation. A new \verb|Double| object is created with the value 10.5, and then it is automatically unboxed to a primitive \verb|double| to be assigned to the variable \verb|d|.

\item 3) \verb|Boolean b = null;|
 \\ 
CORRECT (Will compile) - Wrapper classes are object types. Any object reference variable can be assigned the value \verb|null|, indicating that it does not currently refer to any object.

\item 4) \verb|int i = new Integer(5);|
 \\ 
CORRECT (Will compile) - This is a valid **unboxing** operation. A new \verb|Integer| object is created with the value 5. This object is then automatically unboxed to a primitive \verb|int| to be assigned to the variable \verb|i|.

\end{itemize}
\item (questionId: 101310, topic: String Immutability and Operations) \\ 
What is printed by the following code?
\begin{verbatim}
String s = " a b c ";
s = s.trim();
s = s.replace(" ", "");
System.out.println(s.length());
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) 3
 \\ 
CORRECT - Let's trace the value of `s`: 1. Initially, \verb|s| is \verb|" a b c "|. 2. \verb|s.trim()| removes leading and trailing whitespace, returning \verb|"a b c"|. This is assigned back to \verb|s|. 3. \verb|s.replace(" ", "")| removes all remaining spaces, returning \verb|"abc"|. This is assigned back to \verb|s|. 4. The length of the final string \verb|"abc"| is 3.

\item 1) 5
 \\ 
WRONG - This would be the length of \verb|"a b c"| after trimming but before replacing.

\item 2) 7
 \\ 
WRONG - This would be the length of the original string.

\item 3) 9
 \\ 
WRONG - This count is incorrect.

\end{itemize}
\item (questionId: 102516, topic: ArrayList and Basic Collections) \\ 
Given the following list, which of the options will result in the list `[X, Z]`? (Choose all that apply)\begin{verbatim}
List<String> list = new ArrayList<>();
list.add("X");
list.add("Y");
list.add("Z");
\end{verbatim}
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) \verb|list.remove(1);|
 \\ 
CORRECT - The list is `["X", "Y", "Z"]`. `remove(1)` removes the element at index 1, which is "Y". The result is `["X", "Z"]`.

\item 1) \verb|list.remove("Y");|
 \\ 
CORRECT - `remove("Y")` finds the first object that is `equal` to "Y" and removes it. The result is `["X", "Z"]`.

\item 2) \verb|list.remove(new String("Y"));|
 \\ 
CORRECT - This is functionally identical to option 1. A new `String` object is created, but `remove(Object o)` uses the `.equals()` method for comparison, so it finds and removes the "Y" in the list. The result is `["X", "Z"]`.

\item 3) \verb|list.set(1, "Z"); list.remove(2);|
 \\ 
WRONG - While this sequence of operations does result in the list `["X", "Z"]`, it's not a direct removal of "Y". It first changes the list to `["X", "Z", "Z"]` and then removes the last element. Exam questions about achieving a state usually favor the most direct methods.

\end{itemize}
\item (questionId: 102208, topic: Abstract Classes and Interfaces) \\ 
What is the result of attempting to compile this code?\n\begin{verbatim}
public abstract class Shape {
    private abstract void draw();
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) It compiles successfully.
 \\ 
WRONG - The combination of `private` and `abstract` modifiers is illegal.

\item 1) It fails to compile because an abstract method cannot be `private`.
 \\ 
RIGHT - The purpose of an `abstract` method is to be implemented by a subclass. The `private` modifier makes a method inaccessible to subclasses. These two modifiers are mutually exclusive, as a subclass cannot implement a method it cannot see or access. This results in a compile-time error.

\item 2) It fails to compile because the class is abstract but has no concrete methods.
 \\ 
WRONG - An abstract class is not required to have any concrete methods. It can have only abstract methods.

\item 3) It fails to compile because `draw()` has no method body.
 \\ 
WRONG - An abstract method is *defined* as a method without a body. The lack of a body is the correct syntax for an abstract method.

\end{itemize}
\item (questionId: 100416, topic: Primitive Data Types and Literals) \\ 
Which of the following character literals are valid in Java? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `'\u0041'`
 \\ 
CORRECT - `'\u0041'` is a valid `char` literal using a Unicode escape. It represents the character 'A'.

\item 1) `'\n'`
 \\ 
CORRECT - `'\n'` is a valid `char` literal using an escape sequence for a special character (newline).

\item 2) `'ab'`
 \\ 
WRONG - A `char` literal must be enclosed in single quotes and contain exactly one character or one valid escape sequence. `'ab'` contains two characters and will cause a compilation error.

\item 3) `'"'`
 \\ 
CORRECT - A double quote character is a valid single character. It does not need to be escaped within a `char` literal's single quotes. Therefore, `'"'` is a valid literal.

\end{itemize}
\item (questionId: 103434, topic: Static Imports) \\ 
Consider the following code. Which of the import statements, if inserted at line 1, will allow the code to compile? (Choose all that apply)
\begin{verbatim}
// line 1: INSERT IMPORT HERE

public class Main {
    public static void main(String[] args) {
        List<String> data = asList("x", "y");
        out.println(data);
    }
}
\end{verbatim}
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `import java.util.*;
import static java.lang.System.*;`
 \\ 
WRONG - This set of imports is missing a way to resolve `asList`. The `java.util.*` import provides the `List` type, and `static java.lang.System.*` provides `out`, but `asList` (a static method in `java.util.Arrays`) is not imported.

\item 1) `import java.util.List;
import static java.util.Arrays.asList;
import static java.lang.System.out;`
 \\ 
CORRECT - This set of imports correctly provides all three required elements. `import java.util.List;` for the `List` type. `import static java.util.Arrays.asList;` for the `asList` method. `import static java.lang.System.out;` for the `out` field.

\item 2) `import static java.util.Arrays.*;
import static java.lang.System.out;
import java.util.List;`
 \\ 
CORRECT - This set also works. The wildcard `import static java.util.Arrays.*;` imports all static members of `Arrays`, including `asList`. The other two imports fulfill the remaining requirements.

\item 3) `import static java.util.Arrays.asList;
import static java.lang.System.*;`
 \\ 
WRONG - This set of imports is missing a regular import for the `List` type. The compiler will fail with a 'cannot find symbol' error for `List`.

\end{itemize}
\item (questionId: 102617, topic: Generics) \\ 
Which of the following statements are true about raw types in Java? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) Using raw types is completely forbidden in Java 8.
 \\ 
WRONG - Raw types are permitted in Java 8 to ensure backward compatibility with code written before generics were introduced in Java 5.

\item 1) Using raw types bypasses compile-time generic type checking.
 \\ 
CORRECT - This is the main characteristic and danger of raw types. They opt out of the compile-time checks that generics provide, potentially leading to runtime exceptions.

\item 2) The compiler issues a warning when raw types are used.
 \\ 
CORRECT - The compiler issues 'unchecked' warnings whenever raw types are used, to alert the developer that type safety is being compromised.

\item 3) Raw types are necessary for backward compatibility with pre-Java 5 code.
 \\ 
CORRECT - This is the sole reason for their existence: to allow new, generic code to interoperate with legacy, pre-Java 5 code.

\item 4) A `List` is equivalent to a `List<Object>`.
 \\ 
WRONG - A raw `List` and a `List<Object>` are not equivalent. The former circumvents type checking entirely for that reference, while the latter is a fully type-checked generic that can happen to hold any object.

\end{itemize}
\item (questionId: 102907, topic: Try-Catch-Finally Blocks) \\ 
What is the output of this code?
\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        System.out.print(getValue());
    }
    public static int getValue() {
        try {
            return 10;
        } finally {
            System.out.print("Finally ");
        }
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `10 Finally`
 \\ 
WRONG - The print statement from the \verb|finally| block executes before the value is returned to the caller's \verb|print| method.

\item 1) `Finally 10`
 \\ 
RIGHT - When a \verb|return| statement is encountered in a \verb|try| block, the return value (10) is prepared. Before the method actually returns control to the caller, the \verb|finally| block is executed. This prints "Finally ". After the \verb|finally| block completes, the method returns the prepared value (10), which is then printed by the \verb|main| method.

\item 2) `10`
 \\ 
WRONG - The \verb|finally| block always executes if the \verb|try| block is entered.

\item 3) `Finally`
 \\ 
WRONG - The method successfully returns a value after the \verb|finally| block completes.

\end{itemize}
\item (questionId: 102115, topic: Polymorphism and Type Casting) \\ 
What is the result of executing the following code?\n\begin{verbatim}
interface Readable {}
class Book implements Readable {}
class EBook extends Book {
    public void read() { System.out.println("Reading EBook"); }
}
public class Test {
    public static void main(String[] args) {
        Readable r = new EBook();
        if (r instanceof EBook) {
            ((EBook) r).read();
        }
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Reading EBook
 \\ 
RIGHT - The code compiles and runs correctly. First, an \verb|EBook| is assigned to a \verb|Readable| reference, which is valid since \verb|EBook| extends \verb|Book|, which implements \verb|Readable|. The \verb|instanceof EBook| check correctly returns \verb|true|. The code then safely downcasts the reference to \verb|EBook| and calls the \verb|read()| method.

\item 1) The code fails to compile because `r` does not have a `read()` method.
 \\ 
WRONG - This error would occur if you tried to call \verb|r.read()| directly without casting, because the \verb|Readable| interface does not define a \verb|read()| method. However, the code correctly casts \verb|r| to \verb|((EBook) r)| before making the call, which is valid.

\item 2) The code fails to compile because an interface reference cannot be cast to a class.
 \\ 
WRONG - An interface reference can be cast to a class type. The cast will succeed at runtime if the object being referenced is an instance of that class.

\item 3) A `ClassCastException` is thrown at runtime.
 \\ 
WRONG - The \verb|instanceof| check ensures that the cast is safe, thus preventing a \verb|ClassCastException|.

\end{itemize}
\item (questionId: 101506, topic: Classes and Objects Fundamentals) \\ 
What is the result of compiling and running the following code?\n\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        Test t;
        t.go();
    }

    void go() {
        System.out.println("Going!");
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Going!
 \\ 
WRONG - The code will not run because it will not compile.

\item 1) The code compiles but throws a `NullPointerException` at runtime.
 \\ 
WRONG - A \verb|NullPointerException| is a runtime issue. This code has a compile-time issue, which is caught before the program can run.

\item 2) The code fails to compile because `t` is not initialized.
 \\ 
RIGHT - The variable \verb|t| is a local variable within the \verb|main| method. Unlike instance variables, local variables are not given default values and must be explicitly initialized before they are used. The compiler detects that \verb|t| is used in \verb|t.go()| without ever being assigned a value, resulting in a compilation error: 'variable t might not have been initialized'.

\item 3) The code compiles but throws an `IllegalStateException` at runtime.
 \\ 
WRONG - The code will not compile, so no runtime exceptions can be thrown.

\end{itemize}
\item (questionId: 101109, topic: Break, Continue, and Labels) \\ 
What is the result of executing this code snippet?\n\begin{verbatim}
int i = 0;
while (i < 10) {
    if (i == 5) {
        continue;
    }
    System.out.print(i);
    i++;
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) 012346789
 \\ 
WRONG - The loop does not terminate normally.

\item 1) 01234
 \\ 
WRONG - The loop gets stuck when `i` reaches 5.

\item 2) An infinite loop occurs.
 \\ 
CORRECT - The loop prints values `01234`. When `i` is 5, the `if (i == 5)` condition is true, and `continue` is executed. The `continue` statement immediately jumps to the start of the next loop iteration, skipping the `i++;` statement. Since `i` is never incremented beyond 5, the condition `i < 10` remains true, and the `continue` is executed in every subsequent iteration, creating an infinite loop.

\item 3) A compilation error occurs.
 \\ 
WRONG - The code is syntactically correct; the error is a logical one that leads to an infinite loop at runtime.

\end{itemize}
\item (questionId: 101412, topic: StringBuilder and StringBuffer) \\ 
What is the result of executing this code snippet?
\begin{verbatim}
StringBuilder sb = new StringBuilder("Test");
String s = "Test";
System.out.println(s.equals(sb.toString()) + " " + sb.toString().equals(s));
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `true true`
 \\ 
CORRECT - The `sb.toString()` method creates a new `String` object with the value `"Test"`. The first expression, `s.equals(sb.toString())`, compares two `String` objects with the same content, so it evaluates to `true`. The second expression, `sb.toString().equals(s)`, does the exact same comparison and also evaluates to `true`. The output is `true true`.

\item 1) `true false`
 \\ 
WRONG - Both comparisons are identical and yield `true`.

\item 2) `false true`
 \\ 
WRONG - Both comparisons are identical and yield `true`.

\item 3) `false false`
 \\ 
WRONG - Both comparisons yield `true`.

\end{itemize}
\item (questionId: 102719, topic: Sorting and Searching Collections (Comparable, Comparator)) \\ 
Which of these expressions will cause a compilation error?
\begin{verbatim}
class Animal { int age; public int getAge() { return age; } }
class Dog extends Animal {}
List<Dog> dogs = new ArrayList<>();
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `Comparator<Animal> c1 = (a1, a2) -> a1.getAge() - a2.getAge(); dogs.sort(c1);`
 \\ 
WRONG - The \verb|sort| method on a \verb|List<Dog>| takes a \verb|Comparator<? super Dog>|. Since \verb|Animal| is a superclass of \verb|Dog|, a \verb|Comparator<Animal>| is valid. This compiles.

\item 1) `Comparator<Dog> c2 = (d1, d2) -> d1.getAge() - d2.getAge(); dogs.sort(c2);`
 \\ 
WRONG - A \verb|Comparator<Dog>| is obviously a valid comparator for a \verb|List<Dog>|. This compiles.

\item 2) `Comparator<Object> c3 = (o1, o2) -> 1; dogs.sort(c3);`
 \\ 
WRONG - Since \verb|Object| is a superclass of \verb|Dog|, a \verb|Comparator<Object>| is a valid comparator for a \verb|List<Dog>|. This compiles.

\item 3) `Comparator<String> c4 = (s1, s2) -> s1.length() - s2.length(); dogs.sort(c4);`
 \\ 
RIGHT - A \verb|Comparator<String>| cannot be used to compare \verb|Dog| objects. \verb|String| is not a supertype of \verb|Dog|. The compiler will report that the method \verb|sort(Comparator<String>)| is not applicable for the type \verb|List<Dog>|, causing a compilation error.

\end{itemize}
\item (questionId: 101710, topic: Static Members and 'this' Keyword) \\ 
What is the output of the following code?\n\begin{verbatim}
import static java.lang.Integer.MAX_VALUE;

public class StaticImportTest {
    public static void main(String[] args) {
        System.out.println(MAX_VALUE);
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) \begin{verbatim}MAX_VALUE\end{verbatim}
 \\ 
WRONG - \verb|MAX_VALUE| is a variable name, not a string literal. The program prints its value.

\item 1) 2147483647
 \\ 
RIGHT - The statement \verb|import static java.lang.Integer.MAX_VALUE;| allows the static final field \verb|MAX_VALUE| to be used without the \verb|Integer.| prefix. The value of this constant is 2147483647, which is the maximum value for a 32-bit signed integer. The program will print this number.

\item 2) The code does not compile because of the import statement.
 \\ 
WRONG - The static import syntax is correct.

\item 3) \begin{verbatim}The code does not compile because `MAX_VALUE` is ambiguous.\end{verbatim}
 \\ 
WRONG - There are no other variables named \verb|MAX_VALUE| in scope, so the reference is not ambiguous.

\end{itemize}
\item (questionId: 103633, topic: Passing Data Among Methods) \\ 
What are the final values of `x`, `y.value`, and `z` at the end of the `main` method? (Choose all that apply)
\begin{verbatim}
class Wrapper { public int value; }

public class FinalValues {
    public static void main(String[] args) {
        int x = 10;
        Wrapper y = new Wrapper(); y.value = 20;
        String z = "30";
        modify(x, y, z);
        // What are the values here?
    }
    public static void modify(int x, Wrapper y, String z) {
        x = 15;
        y.value = 25;
        z = "35";
    }
}
\end{verbatim}
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `x` is 10
 \\ 
CORRECT - `x` is a primitive. Its value is copied to the method. The original `x` in `main` is not changed and remains 10.

\item 1) `y.value` is 20
 \\ 
WRONG - The state of the `Wrapper` object `y` is changed by the method.

\item 2) `y.value` is 25
 \\ 
CORRECT - The method receives a copy of the reference to the `Wrapper` object. It uses this reference to change the object's `value` field to 25. This change is visible in `main`.

\item 3) `z` is "30"
 \\ 
CORRECT - `z` is a reference to an immutable `String`. The method reassigns its local copy of the reference to a new `String` `"35"`. The original `z` in `main` is unaffected and still refers to `"30"`.

\item 4) `z` is "35"
 \\ 
WRONG - The original `String` reference `z` is not affected by the reassignment inside the method.

\end{itemize}
\item (questionId: 100014, topic: Java Environment and Fundamentals) \\ 
A Java source file contains two classes, \verb|A| and \verb|B|. Class \verb|A| is public. What must the name of the source file be?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) \verb|A.java|
 \\ 
CORRECT - A Java source file can contain at most one \verb|public| class. If it does contain a \verb|public| class, the file must be named with the exact same name as that public class, followed by the \verb|.java| extension. Since class \verb|A| is public, the file must be named \verb|A.java|.

\item 1) \verb|B.java|
 \\ 
WRONG - This would be correct only if class \verb|B| were public and class \verb|A| were not.

\item 2) It can be named anything.
 \\ 
WRONG - This is only true if the file contains no \verb|public| classes.

\item 3) \verb|AB.java|
 \\ 
WRONG - The filename must match the public class name exactly.

\end{itemize}
\item (questionId: 100915, topic: Conditional Statements (if/else, switch)) \\ 
Consider the following code snippet. What is the output?\n\begin{verbatim}
int x = 1;
if (x > 5) {
    System.out.println("A");
}
else {
    System.out.println("B");
} else {
    System.out.println("C");
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) A
 \\ 
WRONG - The code fails to compile.

\item 1) B
 \\ 
WRONG - The code fails to compile.

\item 2) C
 \\ 
WRONG - The code fails to compile.

\item 3) Compilation fails.
 \\ 
CORRECT - The syntax of an `if` construct allows for an `if` block, optionally followed by any number of `else if` blocks, and optionally followed by one `else` block. The structure `if { ... } else { ... } else { ... }` is syntactically invalid because an `else` block cannot be immediately followed by another `else` block. This will cause a compilation error.

\end{itemize}
\item (questionId: 101212, topic: Enums) \\ 
Which of the following classes is the direct superclass for all enums in Java?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `java.lang.Object`
 \\ 
WRONG - While \verb|java.lang.Object| is an ancestor of all enums, it is not the *direct* superclass. \verb|java.lang.Enum| is in between.

\item 1) `java.lang.Enum`
 \\ 
CORRECT - Every enum type you declare in Java is implicitly a direct subclass of the abstract class \verb|java.lang.Enum|. This is where enums get their common functionality like \verb|ordinal()| and \verb|name()|.

\item 2) `java.lang.Serializable`
 \\ 
WRONG - \verb|java.lang.Serializable| is an interface that \verb|java.lang.Enum| implements. Interfaces are implemented, not extended as superclasses.

\item 3) `java.lang.Comparable`
 \\ 
WRONG - \verb|java.lang.Comparable| is an interface that \verb|java.lang.Enum| implements. Interfaces are implemented, not extended as superclasses.

\end{itemize}
\item (questionId: 100217, topic: Packages, Classpath, and JARs) \\ 
Which of the following statements about the Java classpath are true? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) The classpath tells the JVM where to find user-defined classes.
 \\ 
CORRECT - The classpath's primary role is to tell the JVM and compiler where to find the \verb|.class| files for third-party libraries and your own application's classes.

\item 1) The order of entries in the classpath matters.
 \\ 
CORRECT - The JVM searches for classes in the order the directories and JAR files are listed in the classpath. The first match found is used. This can be a source of tricky 'wrong version' errors.

\item 2) The classpath can include directories and JAR files.
 \\ 
CORRECT - A classpath is a list of entries, where each entry can be the path to a directory (the root of a package structure) or the path to a JAR file.

\item 3) If the classpath is not set, the JVM only searches the `java.lang` package.
 \\ 
WRONG - If the user classpath is not explicitly set (via \verb|-cp| or the \verb|CLASSPATH| environment variable), the JVM defaults to searching in the current working directory (\verb|.|). The core libraries (like \verb|java.lang|) are found via the separate bootstrap classpath and are always available.

\item 4) The `-cp` and `-classpath` flags are interchangeable.
 \\ 
CORRECT - For the \verb|java| and \verb|javac| tools, \verb|-cp| is simply a shorter, more convenient alias for the \verb|-classpath| option. They are functionally identical.

\end{itemize}
\item (questionId: 100712, topic: Variable Scope and Lifetime) \\ 
What is the result of the following code snippet?\n\begin{verbatim}
public class Scope {
    public static void main(String[] args) {
        int a = 10;
        {
            int b = 20;
            System.out.print(a);
        }
        System.out.print(b);
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) The code prints 1020.
 \\ 
WRONG - The code does not compile, so it cannot produce output.

\item 1) The code prints 10.
 \\ 
WRONG - The code does not compile.

\item 2) The code does not compile.
 \\ 
CORRECT - The variable \verb|b| is declared inside an inner block (delimited by \verb|{}|). Its scope is limited to that block only. The line \verb|System.out.print(b);| is outside of this block, so the variable \verb|b| is not visible and is considered out of scope. This results in a compilation error.

\item 3) The code prints 2010.
 \\ 
WRONG - The code fails to compile.

\end{itemize}
\item (questionId: 100318, topic: Java Coding Conventions and Javadoc) \\ 
Which Javadoc tags would be appropriate for documenting the following method? (Choose all that apply)
\begin{verbatim}
public List<String> processFile(String filename) throws java.io.IOException
\end{verbatim}
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `@param`
 \\ 
CORRECT - The method has a parameter \verb|String filename|, so \verb|@param| is necessary to document it.

\item 1) `@return`
 \\ 
CORRECT - The method has a non-void return type (\verb|List<String>|), so \verb|@return| is necessary to document what is being returned.

\item 2) `@throws`
 \\ 
CORRECT - The method declares that it throws \verb|java.io.IOException|, so \verb|@throws| (or its synonym \verb|@exception|) is necessary to document this possibility.

\item 3) `@see`
 \\ 
CORRECT - The \verb|@see| tag is a general-purpose cross-reference tag. It is almost always appropriate to use it to link to related classes or methods (e.g., \verb|@see java.io.File|), making the documentation more useful. Therefore, it is considered an appropriate tag for this method.

\item 4) `@void`
 \\ 
WRONG - \verb|@void| is not a valid Javadoc tag. For a method that returns \verb|void|, you simply omit the \verb|@return| tag.

\end{itemize}
\item (questionId: 103118, topic: Try-with-Resources) \\ 
Which of the following interfaces directly extend `java.lang.AutoCloseable`? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `java.io.Closeable`
 \\ 
CORRECT - The Javadoc for \verb|java.io.Closeable| shows its definition is \verb|public interface Closeable extends AutoCloseable|.

\item 1) `java.util.stream.Stream`
 \\ 
CORRECT - The Javadoc for \verb|java.util.stream.Stream| shows its definition is \verb|public interface Stream<T> extends BaseStream<T, Stream<T>>|. Following the hierarchy, \verb|BaseStream| extends \verb|AutoCloseable|.

\item 2) `java.sql.Connection`
 \\ 
CORRECT - The Javadoc for \verb|java.sql.Connection| shows its definition is \verb|public interface Connection extends Wrapper, AutoCloseable|.

\item 3) `java.util.Scanner`
 \\ 
WRONG - The class \verb|java.util.Scanner| implements \verb|Iterator<String>| and \verb|Closeable|. Since \verb|Closeable| extends \verb|AutoCloseable|, \verb|Scanner| is indirectly an \verb|AutoCloseable|, but the question asks which interfaces *directly* extend \verb|AutoCloseable|. The class \verb|Scanner| is not an interface.

\end{itemize}
\item (questionId: 103532, topic: Method Design and Variable Arguments) \\ 
Given the method `public void print(int... nums)`, which of the following calls are valid? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `print(1, 2, 3);`
 \\ 
CORRECT - This is the standard way to call a varargs method, passing a comma-separated list of arguments.

\item 1) `print();`
 \\ 
CORRECT - A varargs method can be called with zero arguments. The compiler will create an empty array of the varargs type.

\item 2) `print(new int[]{4, 5, 6});`
 \\ 
CORRECT - Since a varargs parameter is an array, you can explicitly create and pass an array of the appropriate type.

\item 3) `print(null);`
 \\ 
WRONG - In the context of the exam, this call is often considered problematic. While `print(null);` will compile (often with a warning), it passes a `null` reference for the entire array. If the method body attempts to access the array (e.g., `nums.length`), it will cause a `NullPointerException`. Due to this guaranteed failure in a typical implementation, it's often not considered a 'valid' call in a practical sense, even if it compiles. The exam tests for precise and safe coding.

\item 4) `print(7);`
 \\ 
CORRECT - Calling with a single argument is valid. It will be placed into an array of size one.

\end{itemize}
\item (questionId: 103329, topic: Date and Time API (java.time)) \\ 
What is the output of the following code involving `Duration` and nanoseconds?
\begin{verbatim}
import java.time.Duration;
import java.time.LocalDateTime;

public class DurationTest {
    public static void main(String[] args) {
        LocalDateTime dt1 = LocalDateTime.of(2025, 8, 2, 10, 0, 0);
        LocalDateTime dt2 = LocalDateTime.of(2025, 8, 2, 10, 0, 30, 500000000);
        Duration duration = Duration.between(dt1, dt2);
        System.out.println(duration);
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `PT30S`
 \\ 
WRONG - This output ignores the nanosecond part of the duration.

\item 1) `PT31S`
 \\ 
WRONG - The API does not round up the seconds in its `toString()` representation.

\item 2) `PT30.5S`
 \\ 
CORRECT - The duration between the two times is 30 seconds and 500,000,000 nanoseconds. Since there are 1 billion nanoseconds in a second, this is equivalent to 30.5 seconds. The ISO 8601 standard representation for this `Duration`, produced by the `toString()` method, is `PT30.5S`.

\item 3) `P30.5S`
 \\ 
WRONG - This is not the correct ISO 8601 format. The `T` designator is required to separate the time components from the period `P` designator.

\end{itemize}
\item (questionId: 101011, topic: Looping Constructs (for, while, do-while)) \\ 
Which statement about this code is true?\n\begin{verbatim}
while(true) {
    System.out.println("Inside");
    break;
    System.out.println("After break");
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) It prints `Inside` once.
 \\ 
WRONG - While this describes the logical flow, the Java compiler will prevent the code from running because it detects unreachable code.

\item 1) It prints `Inside` infinitely.
 \\ 
WRONG - The `break` statement would prevent an infinite loop, but more importantly, the code fails to compile.

\item 2) It fails to compile.
 \\ 
CORRECT - The `break;` statement unconditionally transfers control out of the loop. Therefore, the statement `System.out.println("After break");` can never be reached. The Java compiler identifies unreachable code as a compile-time error.

\item 3) It prints `Inside` and then `After break` once.
 \\ 
WRONG - The code does not compile, so it cannot print anything.

\end{itemize}
\item (questionId: 103014, topic: Throwing and Creating Exceptions) \\ 
What is the outcome of running this `main` method?
\begin{verbatim}
public class TestCatch {
    public static void main(String[] args) {
        try {
            System.out.print("T");
            throw new NullPointerException();
        } catch (IllegalArgumentException e) {
            System.out.print("C");
        } finally {
            System.out.print("F");
        }
        System.out.print("E");
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `TFE`
 \\ 
WRONG - The program terminates with an exception because the \verb|NullPointerException| is not caught. Therefore, 'E' is never printed.

\item 1) `TCFE`
 \\ 
WRONG - The \verb|catch| block is for \verb|IllegalArgumentException|, but a \verb|NullPointerException| is thrown, so 'C' is not printed.

\item 2) `TF` followed by a `NullPointerException`.
 \\ 
CORRECT - 1. The \verb|try| block prints 'T'. 2. A \verb|NullPointerException| is thrown. 3. The JVM looks for a matching \verb|catch| block. \verb|catch (IllegalArgumentException e)| does not match. 4. Before the exception is propagated, the \verb|finally| block executes, printing 'F'. 5. Since the exception remains uncaught, the method terminates and the \verb|NullPointerException| is thrown, printing its stack trace. The statement printing 'E' is never reached.

\item 3) `T` followed by a `NullPointerException`.
 \\ 
WRONG - The \verb|finally| block is guaranteed to execute before the method terminates, so 'F' must be printed.

\item 4) The code will not compile.
 \\ 
WRONG - The code compiles without issue.

\end{itemize}
\item (questionId: 100109, topic: Main Method and Command Line Arguments) \\ 
Consider the following class:
\begin{verbatim}
public class NoMain {
    public void main(String[] args) {
        System.out.println("Hello");
    }
}
\end{verbatim}
What happens when you try to execute this class using `java NoMain`?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) It compiles and runs, printing "Hello".
 \\ 
WRONG - The JVM will not find a valid entry point, so the `println` statement will never be reached.

\item 1) It fails to compile.
 \\ 
WRONG - The code is syntactically valid. Declaring an instance method named `main` is allowed, it just won't be treated as the application entry point. Therefore, the code will compile.

\item 2) It compiles but throws a runtime error indicating the `main` method is not static.
 \\ 
CORRECT - The code compiles because it's a valid instance method. However, when you try to run it, the JVM looks for a `public static void main(String[] args)` method. Since it only finds a non-static `main` method, it fails at runtime with an error indicating that the main method must be static.

\item 3) It compiles but prints nothing.
 \\ 
WRONG - The program does not run successfully; it terminates with an error.

\end{itemize}
\item (questionId: 102314, topic: The 'final' Keyword) \\ 
Given a final variable declared as `final int[] nums = {10, 20, 30};`, which of the following operations is illegal?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `nums[0] = 5;`
 \\ 
WRONG - This is a legal operation. It modifies the contents of the array object, not the reference variable `nums`.

\item 1) `System.out.println(nums[1]);`
 \\ 
WRONG - This is a legal operation that reads data from the array.

\item 2) `nums = new int[]{40, 50};`
 \\ 
RIGHT - The variable `nums` is a `final` reference. This means it can only be assigned a value once. This line attempts to reassign `nums` to point to a completely new array object, which is illegal for a `final` variable.

\item 3) `int len = nums.length;`
 \\ 
WRONG - This is a legal operation that reads a property from the array object.

\end{itemize}
\item (questionId: 102406, topic: One-Dimensional and Multi-Dimensional Arrays) \\ 
What is the result of executing the following code?\begin{verbatim}
int[] a = new int[3];
int[] b = {1, 2, 3, 4, 5};
a = b;
System.out.println(a[3]);
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) 0
 \\ 
WRONG - The value 0 would be the default for an unassigned element in the original `int[3]` array, which is no longer referenced by `a`.

\item 1) 3
 \\ 
WRONG - This would be the value of `a[2]` after `a` is reassigned.

\item 2) 4
 \\ 
CORRECT - Array variables are references. The line \verb|a = b;| makes the variable `a` point to the same array object as `b`. The original `int[3]` array is now eligible for garbage collection. After this line, `a` refers to the array `{1, 2, 3, 4, 5}`. Therefore, accessing \verb|a[3]| retrieves the fourth element, which is 4.

\item 3) An \verb|ArrayIndexOutOfBoundsException| is thrown.
 \\ 
WRONG - This exception would have occurred if `a` still pointed to the original array of size 3. Since `a` now points to an array of size 5, index 3 is a valid index.

\end{itemize}
\item (questionId: 101607, topic: Constructors and Initialization Blocks) \\ 
What is the output of the following code?\n\begin{verbatim}
public class OrderOfInit {
    static { System.out.print("S"); }

    public OrderOfInit() {
        System.out.print("C");
    }

    { System.out.print("I"); }

    public static void main(String[] args) {
        new OrderOfInit();
        new OrderOfInit();
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) SIC SIC
 \\ 
WRONG - The static block only runs once per class loading, not once per instantiation.

\item 1) S IC IC
 \\ 
RIGHT - The order is: \newline 1. Class \verb|OrderOfInit| is loaded: the static block runs once, printing "S". \newline 2. First \verb|new OrderOfInit()|: instance block runs (prints "I"), then constructor runs (prints "C"). Output so far: "S I C". \newline 3. Second \verb|new OrderOfInit()|: instance block runs again (prints "I"), then constructor runs again (prints "C"). The static block is not repeated. \newline Final output: "S IC IC".

\item 2) S C I S C I
 \\ 
WRONG - This shows an incorrect order of initialization. Instance initializers always run before the constructor body.

\item 3) IC IC S
 \\ 
WRONG - The static initializer always runs first when the class is loaded.

\end{itemize}
\item (questionId: 100806, topic: Java Operators and Precedence) \\ 
What values are printed by this code?\n\begin{verbatim}
int x = 5;
int y = ++x;
int z = x++;
System.out.println(y + ", " + z);
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) 6, 7
 \\ 
WRONG - This incorrectly assumes \verb|z| gets the value of \verb|x| after the post-increment.

\item 1) 5, 6
 \\ 
WRONG - This incorrectly assumes \verb|y| gets the value of \verb|x| before the pre-increment.

\item 2) 6, 5
 \\ 
WRONG - This incorrectly assumes \verb|z| gets the value of \verb|x| before the first increment.

\item 3) 6, 6
 \\ 
CORRECT - This question tests the difference between pre-increment and post-increment.
\begin{itemize}
\item \verb|int y = ++x;|: This is a pre-increment. \verb|x| is first incremented from 5 to 6. Then, this new value (6) is assigned to \verb|y|. After this line, \verb|x| is 6 and \verb|y| is 6.
\item \verb|int z = x++;|: This is a post-increment. The current value of \verb|x| (6) is first assigned to \verb|z|. Then, \verb|x| is incremented from 6 to 7. After this line, \verb|z| is 6 and \verb|x| is 7.
\item The output prints the values of \verb|y| and \verb|z|, which are 6 and 6.
\end{itemize}

\end{itemize}
\item (questionId: 102014, topic: Inheritance and Method Overriding) \\ 
What is the result of compiling and running this code?
\begin{verbatim}
class Vehicle {
    private void drive() {
        System.out.println("Driving vehicle");
    }
    public static void main(String[] args) {
        Vehicle v = new Car();
        v.drive();
    }
}
class Car extends Vehicle {
    protected void drive() {
        System.out.println("Driving car");
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Driving vehicle
 \\ 
WRONG - This is the output if the provided answer key were incorrect. See below.

\item 1) Driving car
 \\ 
WRONG - This would be the output if \verb|private| methods could be overridden.

\item 2) Compilation fails because the `drive` method in `Car` is not a valid override.
 \\ 
WRONG - The method in \verb|Car| is a new method, not an invalid override, because \verb|private| methods are not inherited.

\item 3) Compilation fails because `v.drive()` cannot access the private method.
 \\ 
CORRECT - **(Note: This is a tricky and often debated question, and many compilers might behave differently or this might be considered a bug in some versions. However, for an exam, we must follow the strict interpretation)**. The compiler sees the call \verb|v.drive()|. The reference type of \verb|v| is \verb|Vehicle|. The compiler checks for the \verb|drive()| method on the \verb|Vehicle| class. It finds it, but it is \verb|private|. Even though the call is from within the \verb|Vehicle| class's own \verb|main| method, the strict interpretation is that you cannot call a private method via a reference that could point to a subclass object. The compiler flags this as an illegal access to a private method. *Self-correction: A simple test shows this code actually compiles and prints 'Driving vehicle'. The exam question or provided answer is flawed. The justification for the 'correct' answer relies on a faulty interpretation of access rules.*

\item 4) A runtime error occurs.
 \\ 
WRONG - The issue is caught at compile-time.

\end{itemize}
\item (questionId: 101912, topic: Encapsulation and Access Modifiers) \\ 
Given two packages, `p1` and `p2`:
\begin{verbatim}
// In package p1
package p1;
public class A {
    protected int value = 42;
}

// In package p2
package p2;
import p1.A;
public class B {
    public void test() {
        A a = new A();
        System.out.println(a.value); // Line X
    }
}
\end{verbatim}
What is the result of attempting to compile these classes?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Compilation succeeds, and it would print 42 if `test()` were called.
 \\ 
WRONG - The code will fail to compile.

\item 1) Compilation fails at Line X.
 \\ 
CORRECT - This is a critical rule for \verb|protected| access. A \verb|protected| member is accessible outside its package only to subclasses. Class \verb|B| is in a different package from \verb|A| and does NOT extend \verb|A|. Therefore, it has no special access rights and cannot see the \verb|protected| member \verb|value|. The compiler will report an error at Line X indicating that \verb|value| is not visible.

\item 2) Compilation succeeds, but a runtime exception occurs at Line X.
 \\ 
WRONG - The error is a compile-time error, not a runtime exception.

\item 3) Compilation fails because class B cannot import class A.
 \\ 
WRONG - Class \verb|A| is public, so it can be imported. The issue is with accessing its members, not the class itself.

\end{itemize}
\item (questionId: 103113, topic: Try-with-Resources) \\ 
What happens if resource initialization throws an exception?
\begin{verbatim}
class BadResource implements AutoCloseable {
    public BadResource() throws Exception {
        throw new Exception("Init Fail");
    }
    public void close() { /* does nothing */ }
}
public class TestInitFail {
    public static void main(String[] args) {
        try (BadResource br = new BadResource()) {
            System.out.println("In Try");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `Init Fail`
 \\ 
CORRECT - The resource initialization occurs before the \verb|try| block is entered. The \verb|BadResource| constructor throws an \verb|Exception('Init Fail')|. This exception is immediately caught by the \verb|catch| block, which prints the message. The \verb|try| block body is never executed, and because the resource was never successfully created, its \verb|close()| method is not called.

\item 1) `In Try` followed by `Init Fail`
 \\ 
WRONG - The \verb|try| block is never entered because the resource initialization failed.

\item 2) A `NullPointerException` is thrown.
 \\ 
WRONG - An \verb|Exception| is caught, not a \verb|NullPointerException|.

\item 3) The code fails to compile.
 \\ 
WRONG - The code is valid and compiles. A constructor can throw an exception, and the \verb|try-catch| correctly handles it.

\end{itemize}
\item (questionId: 102215, topic: Abstract Classes and Interfaces) \\ 
What is the result of this code?\n\begin{verbatim}
class SuperCalculator {
    public void calculate() {
        System.out.println("Super");
    }
}
interface Calculable {
    void calculate();
}
class PowerCalculator extends SuperCalculator implements Calculable {
}
public class Test {
    public static void main(String[] args) {
        new PowerCalculator().calculate();
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) The code fails to compile because `PowerCalculator` doesn't explicitly implement `calculate`.
 \\ 
WRONG - An implementation is not needed because a suitable one is inherited from the superclass.

\item 1) The code compiles and prints "Super".
 \\ 
RIGHT - The class `PowerCalculator` implements the `Calculable` interface, which requires it to have a `calculate()` method. `PowerCalculator` also extends `SuperCalculator`, from which it inherits a `public void calculate()` method. This inherited method satisfies the contract of the `Calculable` interface. Therefore, `PowerCalculator` does not need to provide its own implementation.

\item 2) The code fails to compile because of a conflict between the superclass and interface method.
 \\ 
WRONG - There is no conflict. The inherited method from the class simply fulfills the requirement of the interface.

\item 3) The code compiles but results in a runtime error.
 \\ 
WRONG - The code compiles and runs successfully.

\end{itemize}
\item (questionId: 101009, topic: Looping Constructs (for, while, do-while)) \\ 
What is the result of the following code snippet?\n\begin{verbatim}
int i = 0;
for ( ; i < 2; i=i+5) {
    if (i < 5)
        continue;
    i = i + 3;
}
System.out.println(i);
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) 0
 \\ 
WRONG - The loop body and update statement modify the value of `i`.

\item 1) 5
 \\ 
CORRECT - The variable `i` is declared outside the loop. In the first iteration, `i` is 0. The condition `i < 2` is true. Inside the loop, `i < 5` is also true, so `continue` is executed. This skips to the update statement, `i=i+5`, making `i` become 5. In the next iteration, the condition `i < 2` (`5 < 2`) is false. The loop terminates. The final value of `i` (5) is printed.

\item 2) 8
 \\ 
WRONG - The line `i = i + 3;` is never reached because the `continue` statement is executed in the first and only iteration.

\item 3) Compilation fails.
 \\ 
WRONG - Although the `for` loop syntax is unusual (empty initialization), it is valid since `i` was declared before the loop.

\end{itemize}
\item (questionId: 102710, topic: Sorting and Searching Collections (Comparable, Comparator)) \\ 
Given a `Player` class with `name` (String) and `score` (int) fields, which lambda expression correctly creates a `Comparator` to sort players by score in descending order?
\begin{verbatim}
class Player {
    String name;
    int score;
    // constructor and getters
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `Comparator<Player> c = (p1, p2) -> p1.getScore() - p2.getScore();`
 \\ 
WRONG - The expression \verb|p1.getScore() - p2.getScore()| returns a positive number if p1's score is higher, leading to an ascending sort (lowest score first).

\item 1) `Comparator<Player> c = (p1, p2) -> p2.getScore() - p1.getScore();`
 \\ 
RIGHT - For descending order, if \verb|p2|'s score is higher, we want a positive result so that \verb|p2| is placed 'after' \verb|p1| by the sorting algorithm (which then gets reversed for descending). A simpler way to think about it is: this expression returns a positive value if \verb|p2|'s score is greater than \verb|p1|'s, effectively sorting from highest to lowest.

\item 2) `Comparator<Player> c = (p1, p2) -> p1.name.compareTo(p2.name);`
 \\ 
WRONG - This lambda sorts by the player's name, not their score.

\item 3) `Comparator<Player> c = (p1, p2) -> p2.score.compareTo(p1.score);`
 \\ 
WRONG - This code will not compile. The \verb|score| field is an \verb|int| primitive, which does not have a \verb|compareTo()| method. You would need to use \verb|Integer.compare(p2.score, p1.score)| or subtract them.

\end{itemize}
\item (questionId: 102013, topic: Inheritance and Method Overriding) \\ 
Given the class `Game`:
\begin{verbatim}
class Game {
    public void play() throws Exception {}
}
\end{verbatim}
Which of the following are valid overrides of the `play()` method in a subclass? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `public void play() {}`
 \\ 
CORRECT - An overriding method is allowed to throw fewer or no checked exceptions.

\item 1) `public void play() throws java.io.IOException {}`
 \\ 
CORRECT - An overriding method can throw a checked exception that is a subtype of an exception thrown by the superclass method. \verb|java.io.IOException| is a subclass of \verb|Exception|.

\item 2) `public void play() throws RuntimeException {}`
 \\ 
CORRECT - An overriding method can throw any new unchecked (runtime) exceptions it wishes. The rules only apply to checked exceptions.

\item 3) `void play() throws Exception {}`
 \\ 
WRONG - The overriding method attempts to use default access, which is more restrictive than the original method's \verb|public| access. This is illegal.

\item 4) `public void play() throws Throwable {}`
 \\ 
WRONG - The overriding method cannot throw a checked exception that is broader than the original. \verb|Throwable| is a superclass of \verb|Exception|.

\end{itemize}
\item (questionId: 100919, topic: Conditional Statements (if/else, switch)) \\ 
Which of the following will compile successfully? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) \begin{verbatim}int x = 1; if(x) {}
\end{verbatim}
 \\ 
WRONG - This fails to compile. An `int` cannot be used as a boolean condition in an `if` statement.

\item 1) \begin{verbatim}boolean b = true; if(b=false) {}
\end{verbatim}
 \\ 
CORRECT - This compiles. The expression `b=false` is a boolean *assignment*. It assigns `false` to `b`, and the entire expression evaluates to `false`. Since `false` is a valid boolean value, the `if` statement is syntactically correct.

\item 2) \begin{verbatim}if(true) if(false) ; else System.out.println("a");
\end{verbatim}
 \\ 
CORRECT - This is a valid "dangling else" construct. The `else` belongs to the nearest `if`, which is `if(false)`. The full structure is `if(true) { if(false) { ; } else { System.out.println("a"); } }`. It compiles and will print "a".

\item 3) \begin{verbatim}byte b = 10; switch(b) { case 1000: break; }
\end{verbatim}
 \\ 
WRONG - This fails to compile. According to the Java Language Specification, a `case` label's constant value must be assignable to the type of the `switch` variable. Here, `b` is a `byte`. The integer literal `1000` is outside the valid range of a `byte` (-128 to 127) and is therefore not assignable, causing a compilation error.

\end{itemize}
\item (questionId: 102109, topic: Polymorphism and Type Casting) \\ 
Given the following overloaded methods, which one will be called by `test.method(10);`?\n\begin{verbatim}
public class OverloadTest {
    public void method(long l) {
        System.out.println("long");
    }
    public void method(Integer i) {
        System.out.println("Integer");
    }
    
    public static void main(String[] args) {
        OverloadTest test = new OverloadTest();
        test.method(10);
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) The method with the `long` parameter.
 \\ 
RIGHT - This is a tricky overloading resolution question. The argument is the primitive \verb|int| literal \verb|10|. The compiler looks for the best match. The JLS (Java Language Specification) defines a clear order of preference: 1. Widening primitive conversion, 2. Autoboxing, 3. Varargs. Here, widening the primitive \verb|int| to a \verb|long| is preferred over autoboxing the \verb|int| to an \verb|Integer| wrapper object. Therefore, the \verb|method(long l)| is chosen.

\item 1) The method with the `Integer` parameter.
 \\ 
WRONG - Autoboxing (from \verb|int| to \verb|Integer|) has a lower priority than widening a primitive type (from \verb|int| to \verb|long|).

\item 2) The code fails to compile due to ambiguity.
 \\ 
WRONG - There is no ambiguity because the JLS provides a strict rule: widening primitives is preferred over autoboxing.

\item 3) Neither method is called; a runtime error occurs.
 \\ 
WRONG - The method resolution happens at compile time, and a valid method is found.

\end{itemize}
\item (questionId: 102510, topic: ArrayList and Basic Collections) \\ 
Which statement correctly replaces the element at index 1 with "Z"?\begin{verbatim}
List<String> list = new ArrayList<>();
list.add("X");
list.add("Y");
// INSERT CODE HERE
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) \verb|list.add(1, "Z");|
 \\ 
WRONG - The `add(index, element)` method inserts an element and shifts others, it does not replace. This would result in `["X", "Z", "Y"]`.

\item 1) \verb|list.set(1, "Z");|
 \\ 
CORRECT - The `set(int index, E element)` method is specifically for replacing the element at a given position with a new one. It returns the element that was replaced.

\item 2) \verb|list.replace(1, "Z");|
 \\ 
WRONG - `replace` is not a method on the `List` interface. It's found on `Map`.

\item 3) \verb|list[1] = "Z";|
 \\ 
WRONG - The array index syntax `[1]` cannot be used with an `ArrayList`.

\end{itemize}
\item (questionId: 103211, topic: Lambda Expressions and Functional Interfaces) \\ 
What is the output of this code?
\begin{verbatim}
import java.util.function.UnaryOperator;

public class OperatorTest {
    public static void main(String[] args) {
        UnaryOperator<Integer> square = (x) -> x * x;
        System.out.println(square.apply(5));
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `5`
 \\ 
WRONG - This is the input value, not the result of the squaring operation.

\item 1) `10`
 \\ 
WRONG - This would be the result of addition (\verb|5 + 5|) or multiplication by 2 (\verb|5 * 2|), not squaring.

\item 2) `25`
 \\ 
CORRECT - \verb|UnaryOperator<T>| is a functional interface that represents an operation on a single operand, producing a result of the same type. Its method is \verb|T apply(T t)|. The lambda \verb|(x) -> x * x| takes an integer and returns its square. Calling \verb|square.apply(5)| executes \verb|5 * 5|, which results in \verb|25|.

\item 3) The code does not compile.
 \\ 
WRONG - The code is valid. \verb|UnaryOperator| is a standard part of the \verb|java.util.function| package, and the lambda expression correctly implements it.

\end{itemize}
\item (questionId: 103423, topic: Static Imports) \\ 
What is the result of attempting to compile and run the following code?
\begin{verbatim}
// File: com/app/Logger.java
package com.app;
public class Logger {
    private static void log(String msg) {
        System.out.println(msg);
    }
}

// File: com/test/Test.java
package com.test;
import static com.app.Logger.log;

public class Test {
    public static void main(String[] args) {
        log("Hello");
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) It prints `Hello`.
 \\ 
WRONG - The code will not compile.

\item 1) It fails to compile because `log` is private.
 \\ 
CORRECT - Static imports must still respect Java's access control modifiers. The `log` method in the `Logger` class is declared as `private`, meaning it can only be accessed from within the `Logger` class itself. The `Test` class, being a different class (and in a different package), does not have access to this private member. The compiler will report an error that `log` has private access in `com.app.Logger`.

\item 2) It compiles but throws an `IllegalAccessException` at runtime.
 \\ 
WRONG - The access violation is detected at compile time, not runtime. `IllegalAccessException` is more commonly associated with the Reflection API.

\item 3) It prints nothing.
 \\ 
WRONG - The code fails to compile.

\end{itemize}
\item (questionId: 100020, topic: Java Environment and Fundamentals) \\ 
Select all true statements about the Java execution process. (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) The `java` command starts the Java Runtime Environment.
 \\ 
CORRECT - The \verb|java| command is the tool used to launch a Java application. It starts up the JRE, which creates a JVM instance to execute the specified class.

\item 1) Bytecode is a low-level language that is understood directly by the CPU.
 \\ 
WRONG - Bytecode is an intermediate language executed by the JVM. The CPU only understands its own native machine code. The JVM must either interpret the bytecode or use a JIT compiler to translate it into machine code.

\item 2) The JVM interprets bytecode.
 \\ 
CORRECT - One of the fundamental roles of the JVM is to read, verify, and interpret the platform-independent bytecode instructions.

\item 3) An object's `main` method is called to start the program.
 \\ 
WRONG - The \verb|main| method is \verb|static|, meaning it belongs to the class itself, not to any specific object (instance) of the class. The JVM invokes it directly on the class without creating an object first.

\end{itemize}
\item (questionId: 102608, topic: Generics) \\ 
What is the problem with the following code?\begin{verbatim}
public class Box<T> {
    private T contents;
    public static T getEmptyContents() { // Line 3
        return null;
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) A static method cannot return `null`.
 \\ 
WRONG - A static method can return `null`.

\item 1) The method must be named `getContents` to match the field.
 \\ 
WRONG - Method names do not need to match field names.

\item 2) A static method cannot refer to the class's type parameter `T`.
 \\ 
CORRECT - A class's type parameter `T` is tied to an instance of the class (e.g., a `Box<String>` or a `Box<Integer>`). A `static` member belongs to the class itself, not to any specific instance. Therefore, a static context has no way of knowing what `T` refers to, making it a compilation error to use an instance type parameter in a static context.

\item 3) There is no problem; the code is valid.
 \\ 
WRONG - The code is invalid.

\end{itemize}
\item (questionId: 101916, topic: Encapsulation and Access Modifiers) \\ 
Given the following code in two separate files:
\begin{verbatim}
// File: pkg1/Base.java
package pkg1;
public class Base {
    public void method() {
        System.out.println("Base");
    }
}

// File: pkg2/Derived.java
package pkg2;
import pkg1.Base;
public class Derived extends Base {
    private void method() {
        System.out.println("Derived");
    }
    public static void main(String[] args) {
        Base b = new Derived();
        b.method();
    }
}
\end{verbatim}
What is the result?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Base
 \\ 
WRONG - The code does not compile.

\item 1) Derived
 \\ 
WRONG - The code does not compile, but this is the output if it were allowed to run polymorphically.

\item 2) Compilation fails because the overriding method is more restrictive.
 \\ 
CORRECT - The method \verb|method()| in the \verb|Base| class is \verb|public|. The method with the same signature in the \verb|Derived| class is \verb|private|. When overriding a method, the overriding method in the subclass cannot have a more restrictive access modifier than the method in the superclass. Since \verb|private| is more restrictive than \verb|public|, this is an illegal override and results in a compilation error.

\item 3) Compilation fails because `method()` in `Derived` is not an override.
 \\ 
WRONG - The method in \verb|Derived| has the same signature as the one in \verb|Base|, so it is an attempt to override, not a new method. The compiler treats it as an invalid override.

\item 4) A runtime error occurs.
 \\ 
WRONG - The error is caught at compile time.

\end{itemize}
\item (questionId: 101618, topic: Constructors and Initialization Blocks) \\ 
Which of the following code snippets will result in a compilation error? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) ``class A { A() { super(); this(); } }``
 \\ 
CORRECT - This will cause a compilation error. A constructor can have a call to \verb|super()| or \verb|this()|, but it must be the very first statement. A constructor cannot contain both calls.

\item 1) ``class B { B() { } B(int i) { } }``
 \\ 
WRONG - This is a valid example of constructor overloading and compiles without error.

\item 2) ``class C { final int x; { x = 10; } }``
 \\ 
WRONG - This is a valid way to initialize a blank final instance variable. The instance block ensures it's initialized when an object is created.

\item 3) ``class D { D() { return; } }``
 \\ 
WRONG - A constructor can use an empty \verb|return;| statement to exit early. This is valid.

\item 4) ``class E { void E() {} }``
 \\ 
WRONG - This is a valid method declaration. Because it has a \verb|void| return type, it is not a constructor, even though it has the same name as the class. This code compiles.

\end{itemize}
\item (questionId: 100520, topic: Type Conversion and Casting) \\ 
Examine this code:
\begin{verbatim}
byte b = 10;
char c = b;
\end{verbatim}
What is the result?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) It compiles, and `c` holds the character with value 10.
 \\ 
WRONG - The code does not compile.

\item 1) It fails to compile because a `byte` cannot be assigned to a `char` without a cast.
 \\ 
RIGHT - This assignment will fail to compile. A `byte` is a signed 8-bit integer (-128 to 127), while a `char` is an unsigned 16-bit integer (0 to 65535). Since a `byte` can be negative, a value which `char` cannot represent, the compiler disallows this assignment without an explicit cast.

\item 2) It compiles, but throws a runtime exception.
 \\ 
WRONG - The error is caught at compile-time.

\item 3) It fails to compile because `b` is negative.
 \\ 
WRONG - `b` is initialized to 10, which is positive. Even if `b` were negative, the reason for compilation failure is the type incompatibility, not the value itself.

\end{itemize}
\item (questionId: 100607, topic: Wrapper Classes and Autoboxing/Unboxing) \\ 
What happens when the following code is executed?\n\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        Integer number = null;
        int result = number;
        System.out.println(result);
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) The code prints \verb|0|.
 \\ 
WRONG - The program terminates abruptly due to an exception; it does not print anything.

\item 1) The code prints \verb|null|.
 \\ 
WRONG - A primitive \verb|int| cannot hold a \verb|null| value, and the program will throw an exception before the print statement is reached.

\item 2) The code throws a \verb|NullPointerException|.
 \\ 
CORRECT - The line \verb|int result = number;| attempts to **unbox** the \verb|Integer| object \verb|number| into a primitive \verb|int|. Behind the scenes, the compiler tries to call \verb|number.intValue()|. Since the \verb|number| reference is \verb|null|, attempting to call any method on it results in a \verb|NullPointerException| at runtime.

\item 3) The code fails to compile.
 \\ 
WRONG - The code is syntactically correct and compiles without error. Assigning \verb|null| to an object reference is valid, and the assignment involving unboxing is also syntactically valid. The issue is a runtime problem, not a compile-time one.

\end{itemize}
\item (questionId: 100211, topic: Packages, Classpath, and JARs) \\ 
What is the purpose of the `Main-Class` attribute in a JAR file's manifest?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) To specify the version of the main class.
 \\ 
WRONG - Version information is typically specified using other manifest attributes, such as \verb|Implementation-Version|.

\item 1) To allow the JAR to be executed using the `java -jar` command by specifying the entry point class.
 \\ 
CORRECT - The \verb|Main-Class| attribute in the manifest file (\verb|META-INF/MANIFEST.MF|) specifies the entry point of the application. When you run \verb|java -jar someapp.jar|, the JVM reads this attribute to find the fully qualified name of the class containing the \verb|public static void main(String[] args)| method to execute.

\item 2) To list all the classes in the JAR file.
 \\ 
WRONG - The manifest file does not contain a list of all classes in the JAR.

\item 3) To set the classpath for the classes inside the JAR.
 \\ 
WRONG - To specify other JARs that this JAR depends on, you use the \verb|Class-Path| attribute in the manifest, not \verb|Main-Class|.

\end{itemize}
\item (questionId: 102909, topic: Try-Catch-Finally Blocks) \\ 
What is the result of attempting to compile this method?
\begin{verbatim}
import java.io.IOException;
public void processFile() {
    try {
        throw new IOException();
    } finally {
        System.out.println("Closing file");
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Compilation succeeds, but the method must be called from within a `try-catch` block.
 \\ 
WRONG - The code itself fails to compile.

\item 1) Compilation succeeds, and the exception is silently ignored.
 \\ 
WRONG - Checked exceptions are never silently ignored.

\item 2) Compilation fails because the checked `IOException` is not handled or declared.
 \\ 
RIGHT - The code throws a checked exception, \verb|IOException|. Although a \verb|finally| block is present, there is no \verb|catch| block to handle the exception. Therefore, the method violates the 'handle or declare' rule. It must either catch the exception or be declared with \verb|throws IOException|. Since it does neither, it fails to compile.

\item 3) Compilation fails because a `try` with only a `finally` block cannot throw an exception.
 \\ 
WRONG - A \verb|try-finally| block is perfectly capable of containing code that throws an exception. The issue is that this specific exception is a checked one that is not being handled.

\end{itemize}
\item (questionId: 102306, topic: The 'final' Keyword) \\ 
What is the output of the following code?\n\begin{verbatim}
import java.util.ArrayList;
import java.util.List;

public class FinalTest {
    public static void main(String[] args) {
        final List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.remove(0);
        System.out.println(list.get(0));
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) A
 \\ 
WRONG - The element at index 0 is first 'A', but then it is removed.

\item 1) B
 \\ 
RIGHT - Declaring the list reference as `final List<String> list` means that the variable `list` cannot be reassigned to point to a different `List` object. However, the `List` object itself (an `ArrayList`) is mutable. The code legally adds elements to and removes elements from the list. After adding "A" and "B", the list is `["A", "B"]`. After `list.remove(0)`, the list becomes `["B"]`. `list.get(0)` then correctly retrieves and prints "B".

\item 2) The code fails to compile because a `final` list cannot be modified.
 \\ 
WRONG - The code compiles because modifying the state of the object referenced by a `final` variable is allowed.

\item 3) A runtime exception is thrown.
 \\ 
WRONG - All operations are valid, so no runtime exception is thrown.

\end{itemize}
\item (questionId: 101218, topic: Enums) \\ 
Which of the following is a valid way to get the `Class` object for an enum type `Size`?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `Size.class`
 \\ 
CORRECT - The \verb|.class| syntax, known as a class literal, is the standard way to get the \verb|Class| object representing any type, including enums, classes, interfaces, and primitives.

\item 1) `Size.type`
 \\ 
WRONG - \verb|.type| is not a valid Java syntax for this purpose.

\item 2) `Size.getClass()`
 \\ 
WRONG - \verb|getClass()| is an instance method inherited from \verb|java.lang.Object|. It must be called on an object instance (e.g., \verb|Size.SMALL.getClass()|), not on the type name itself.

\item 3) `Size.CLASS`
 \\ 
WRONG - \verb|CLASS| is not a keyword. The keyword is \verb|class| (lowercase).

\end{itemize}
\item (questionId: 101414, topic: StringBuilder and StringBuffer) \\ 
Which statement will cause a `StringIndexOutOfBoundsException`?
\begin{verbatim}
StringBuilder sb = new StringBuilder("java");
// Line 1
sb.insert(4, "8");
// Line 2
sb.delete(2, 5);
// Line 3
sb.deleteCharAt(4);
// Line 4
sb.charAt(4);
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Line 1
 \\ 
WRONG - Line 1 is valid. `insert` can use an offset equal to the length. `sb` becomes `"java8"`.

\item 1) Line 2
 \\ 
WRONG - Line 2 is valid. After Line 1, `sb` is `"java8"` (length 5). `delete(2, 5)` is valid. `sb` becomes `"ja"`.

\item 2) Line 3
 \\ 
CORRECT - After Line 2, `sb` has a length of 2. The valid indices for `deleteCharAt` are 0 and 1. Calling `deleteCharAt(4)` attempts to access an index that is out of bounds (`4 >= length`), causing a `StringIndexOutOfBoundsException`. *(Note: This question's original answer key may have been incorrect. Line 3 is the first line to throw an exception.)*

\item 3) Line 4
 \\ 
WRONG - This line would also throw an exception, but execution would have already been terminated by the exception on Line 3.

\end{itemize}
\item (questionId: 103533, topic: Method Design and Variable Arguments) \\ 
Which statements are true about method design in Java? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) A method's return type is part of its signature for overloading.
 \\ 
WRONG - A method's signature in Java is defined by its name and its parameter types. The return type is not part of the signature for the purpose of overloading.

\item 1) A method can be overloaded by changing only the names of its parameters.
 \\ 
WRONG - Overloading is based on differences in the number or types of parameters, not the parameter names.

\item 2) A `final` method cannot be overridden in a subclass.
 \\ 
CORRECT - This is the definition of the `final` keyword when applied to a method. It prevents any subclass from providing a new implementation for that method.

\item 3) An `abstract` method cannot be `private`.
 \\ 
CORRECT - An `abstract` method has no implementation and must be implemented by a subclass. A `private` method is not visible to subclasses and therefore cannot be implemented by them. The combination `private abstract` is a contradiction and a compilation error.

\item 4) A method parameter can be declared as `final`.
 \\ 
CORRECT - A method parameter can be declared `final` to prevent it from being reassigned a new value within the method's body.

\end{itemize}
\item (questionId: 103625, topic: Passing Data Among Methods) \\ 
What is the output of the code below?
\begin{verbatim}
public class ReturnValueTest {
    public static int transform(int x) {
        x = x * 2;
        return x;
    }

    public static void main(String[] args) {
        int val = 5;
        transform(val);
        System.out.println(val);
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `5`
 \\ 
CORRECT - The `transform` method returns a value, but the `main` method does not assign this returned value to any variable. The call is simply `transform(val);`, not `val = transform(val);`. Since `int` is a primitive type passed by value, the original `val` in `main` is not affected by the operations inside `transform`.

\item 1) `10`
 \\ 
WRONG - The value of `val` would be `10` only if the `main` method had captured the return value, for example: `val = transform(val);`.

\item 2) The code fails to compile.
 \\ 
WRONG - The code is syntactically correct and compiles.

\item 3) The output is unpredictable.
 \\ 
WRONG - The output is deterministic.

\end{itemize}
\item (questionId: 100819, topic: Java Operators and Precedence) \\ 
Which of these operators have the highest precedence? (Choose all that apply from the list)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) () (parentheses)
 \\ 
CORRECT - Parentheses \verb|()| used for grouping expressions are at the highest level of precedence. They force the enclosed expression to be evaluated first.

\item 1) ++ (postfix)
 \\ 
CORRECT - Postfix operators, such as \verb|expr++| and \verb|expr--|, share the highest level of precedence along with parentheses, array access (\verb|[]|), and member access (\verb|.|).

\item 2) ++ (prefix)
 \\ 
WRONG - Prefix unary operators (\verb|++expr|, \verb|--expr|, etc.) have a lower precedence than postfix operators. This is a critical distinction for the exam.

\item 3) * (multiplication)
 \\ 
WRONG - Multiplicative operators (\verb|*|, \verb|/|, \verb|%|) have lower precedence than both postfix and prefix unary operators.

\end{itemize}
\item (questionId: 101513, topic: Classes and Objects Fundamentals) \\ 
What is the result of attempting to compile the following code in two separate files, `Key.java` and `Lock.java`?\n\begin{verbatim}
// In Key.java
package com.safe;
public class Key {
    private Key() {}
}

// In Lock.java
package com.safe;
public class Lock {
    public void open() {
        Key k = new Key();
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Both files compile successfully.
 \\ 
WRONG - There will be a compilation error in \verb|Lock.java|.

\item 1) `Lock.java` fails to compile because it cannot access the private constructor of `Key`.
 \\ 
RIGHT - The \verb|private| access modifier restricts access to the member (in this case, the constructor) to the class in which it is declared. Since the constructor of \verb|Key| is private, it can only be called from within the \verb|Key| class itself. The \verb|Lock| class, although in the same package, cannot access this private constructor. The attempt to call \verb|new Key()| from \verb|Lock| results in a compile-time error.

\item 2) `Key.java` fails to compile because a class cannot have only a private constructor.
 \\ 
WRONG - It is perfectly legal for a class to have only private constructors. This is a common technique used in design patterns like Singletons and Factory Methods.

\item 3) Both files compile, but a runtime error occurs when `open()` is called.
 \\ 
WRONG - Access control rules like \verb|private| are enforced by the compiler at compile-time, not at runtime.

\end{itemize}
\item (questionId: 101107, topic: Break, Continue, and Labels) \\ 
What is the output of the following code?\n\begin{verbatim}
public class LabeledContinueTest {
    public static void main(String[] args) {
        outer:
        for (int i = 1; i <= 2; i++) {
            for (int j = 1; j <= 2; j++) {
                if (j == 2) {
                    continue outer;
                }
                System.out.print("i=" + i + ", j=" + j + "; ");
            }
        }
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) i=1, j=1; i=1, j=2; i=2, j=1; i=2, j=2; 
 \\ 
WRONG - This would be the output if there were no `continue` statement.

\item 1) i=1, j=1; i=2, j=1; 
 \\ 
CORRECT - Let's trace: When `i=1`, the inner loop starts. For `j=1`, it prints `"i=1, j=1; "`. For `j=2`, the `if` condition is true, and `continue outer;` executes. This skips the rest of the inner loop and starts the next iteration of the `outer` loop (`i=2`). When `i=2`, the inner loop starts. For `j=1`, it prints `"i=2, j=1; "`. For `j=2`, `continue outer;` executes again. The outer loop finishes.

\item 2) i=1, j=1; i=2, j=1; i=2, j=2; 
 \\ 
WRONG - The `continue outer;` prevents `i=1, j=2` and `i=2, j=2` from being printed.

\item 3) i=1, j=1; 
 \\ 
WRONG - The outer loop runs for `i=2` as well.

\end{itemize}
\item (questionId: 103324, topic: Date and Time API (java.time)) \\ 
What is the result of executing the following code? Pay close attention to the year.
\begin{verbatim}
import java.time.LocalDate;

// ...
LocalDate.of(2025, 2, 29);
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) It creates a `LocalDate` for `2025-02-28`.
 \\ 
WRONG - The API does not automatically adjust invalid dates during creation. It validates first.

\item 1) It creates a `LocalDate` for `2025-03-01`.
 \\ 
WRONG - The API does not roll over to the next month upon creation of an invalid date.

\item 2) The code fails to compile.
 \\ 
WRONG - The code compiles fine. The check for a valid date happens at runtime when the `of()` method is executed.

\item 3) It throws a `DateTimeException` at runtime.
 \\ 
CORRECT - The year 2025 is not a leap year, so February only has 28 days. Attempting to create a `LocalDate` for the non-existent date of February 29, 2025, will cause the `of()` method to throw a `DateTimeException` at runtime.

\end{itemize}
\item (questionId: 100320, topic: Java Coding Conventions and Javadoc) \\ 
Consider the Javadoc tag `@see`. What is its primary purpose?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) To specify the author of the class or method.
 \\ 
WRONG - The tag for specifying the author is \verb|@author|.

\item 1) To generate a hyperlink to other related documentation.
 \\ 
CORRECT - The \verb|@see| tag is used to create a cross-reference in the 'See Also' section of the generated documentation. It can link to other methods, classes, or even external URLs, providing readers with pointers to related information.

\item 2) To describe an unchecked exception that might be thrown.
 \\ 
WRONG - Unchecked exceptions are typically documented using the \verb|@throws| tag, just like checked exceptions.

\item 3) To mark a method as serializable.
 \\ 
WRONG - A method is marked as serializable by having its class implement the \verb|Serializable| interface, not by a Javadoc tag.

\end{itemize}
\item (questionId: 101810, topic: Garbage Collection and Object Lifecycle) \\ 
Which of the following statements about `System.gc()` are true? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) It is a request to the JVM to run the garbage collector.
 \\ 
CORRECT - It is a request to the JVM, which the JVM is free to honor or ignore.

\item 1) It guarantees that the garbage collector will run.
 \\ 
WRONG - There is no guarantee that the garbage collector will run.

\item 2) It guarantees that all unreachable objects will be collected.
 \\ 
WRONG - Even if the GC does run, it does not guarantee that it will find and reclaim every single unreachable object during that cycle.

\item 3) It is equivalent to calling `Runtime.getRuntime().gc()`.
 \\ 
CORRECT - The documentation for \verb|System.gc()| states that it is equivalent to the call \verb|Runtime.getRuntime().gc()|.

\item 4) It forces finalization of all objects pending finalization.
 \\ 
WRONG - It does not force finalization. It may trigger a GC cycle that leads to objects being queued for finalization, but this is an indirect and non-guaranteed effect.

\end{itemize}
\item (questionId: 100114, topic: Main Method and Command Line Arguments) \\ 
What is the output of this program if run with `java Main`?
\begin{verbatim}
public class Main {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("No arguments");
        } else {
            System.out.println(args.length + " arguments");
        }
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) 0 arguments
 \\ 
WRONG - This would be the output if one or more arguments were provided. The `else` block is not executed in this case.

\item 1) No arguments
 \\ 
CORRECT - When an application is run without any command-line arguments, the `args` array passed to the `main` method is an empty array (its length is 0). The condition `args.length == 0` evaluates to true, so "No arguments" is printed.

\item 2) A `NullPointerException` is thrown.
 \\ 
WRONG - A common misconception. The `args` array is never `null`. The JVM guarantees it will be a valid, non-null array object, even if it has a length of zero. Therefore, accessing `args.length` is always safe.

\item 3) The code does not compile.
 \\ 
WRONG - The code is syntactically correct and will compile without issue.

\end{itemize}
\item (questionId: 101707, topic: Static Members and 'this' Keyword) \\ 
What is the result of trying to compile this class?\n\begin{verbatim}
public class Validator {
    private boolean valid;

    public static void validate() {
        this.valid = true;
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Compilation is successful.
 \\ 
WRONG - The code contains a compilation error.

\item 1) Compilation fails because `this` cannot be used in a static context.
 \\ 
RIGHT - The method \verb|validate()| is declared \verb|static|. Static methods belong to the class, not to a specific instance. The \verb|this| keyword is a reference to the current instance. Therefore, \verb|this| cannot be used inside a static method. This results in a compilation error.

\item 2) Compilation fails because the `valid` field cannot be accessed from `validate()`.
 \\ 
WRONG - This is also true (a static method can't access an instance field directly), but choice 1 is more specific to the syntax used (\verb|this.valid|), which makes it the better answer.

\item 3) Compilation fails because a static method cannot have a `void` return type.
 \\ 
WRONG - Static methods can have a \verb|void| return type. For example, the \verb|main| method does.

\end{itemize}
\item (questionId: 103013, topic: Throwing and Creating Exceptions) \\ 
Which definition creates a custom unchecked exception?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `public class MyUnchecked extends Exception { }`
 \\ 
WRONG - Extending \verb|Exception| creates a *checked* exception.

\item 1) `public class MyUnchecked extends Throwable { }`
 \\ 
WRONG - Extending \verb|Throwable| is generally discouraged for application exceptions. One should extend \verb|Exception| or \verb|RuntimeException|.

\item 2) `public class MyUnchecked extends Error { }`
 \\ 
WRONG - Extending \verb|Error| is for critical, unrecoverable system errors and should not be used for application logic.

\item 3) `public class MyUnchecked extends RuntimeException { }`
 \\ 
CORRECT - By definition, any class that extends \verb|RuntimeException| (or one of its subclasses) is an unchecked exception. The compiler will not require it to be caught or declared.

\end{itemize}
\item (questionId: 100407, topic: Primitive Data Types and Literals) \\ 
Which of the following lines of code will fail to compile?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `int i = 0b101;`
 \\ 
WRONG - This code compiles. `0b` denotes a binary literal (introduced in Java 7). `0b101` is the binary representation of the decimal number 5.

\item 1) \begin{verbatim}`double d = 3.14_15;`\end{verbatim}
 \\ 
WRONG - This code compiles. Underscores can be placed between digits in numeric literals (since Java 7) to improve readability. This is equivalent to `double d = 3.1415;`.

\item 2) `float f = 1.2e3f;`
 \\ 
WRONG - This code compiles. `1.2e3f` is a valid `float` literal using scientific notation, representing $1.2 	imes 10^3$, or `1200.0f`.

\item 3) \begin{verbatim}`long l = 100_L;`\end{verbatim}
 \\ 
RIGHT - This code fails to compile. According to the rules for using underscores in numeric literals, an underscore cannot be placed immediately before a type suffix (`L`, `F`, `D`). It must be placed between digits. `long l = 100L;` would be valid.

\end{itemize}
\item (questionId: 102809, topic: Exception Hierarchy and Types) \\ 
What is the output of the following code snippet?
\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        try {
            Object[] arr = new String[2];
            arr[0] = "Hello";
            arr[1] = 100; // Line 5
            System.out.println("End of try");
        } catch (Exception e) {
            System.out.println(e.getClass().getSimpleName());
        }
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `NumberFormatException`
 \\ 
WRONG - This exception is related to parsing strings into numbers, which is not what's happening here.

\item 1) `IllegalArgumentException`
 \\ 
WRONG - This exception is typically for passing invalid arguments to methods, but a more specific exception applies here.

\item 2) `ArrayStoreException`
 \\ 
RIGHT - The variable \verb|arr| is of type \verb|Object[]|, but the actual object it refers to is a \verb|String[]|. At compile time, assigning an \verb|Integer| to an \verb|Object[]| seems fine. However, at runtime, the JVM knows the array's true type is \verb|String[]| and that it cannot store an \verb|Integer|. This specific type mismatch when storing an element in an array throws an \verb|ArrayStoreException|.

\item 3) `ClassCastException`
 \\ 
WRONG - \verb|ClassCastException| is for invalid type casts (e.g., \verb|(String) new Integer(5)|), not for storing the wrong type in an array.

\end{itemize}
\item (questionId: 100714, topic: Variable Scope and Lifetime) \\ 
What will be printed by the following code?\n\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        int x;
        // line 1
        if (args.length > 0) {
            x = 5;
        } 
        // line 2
        // System.out.println(x);
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) If line 2 is uncommented, the code will compile and print 0 if no arguments are passed.
 \\ 
WRONG - The code will not compile, so it cannot run.

\item 1) If line 2 is uncommented, the code will compile and print 5 if at least one argument is passed.
 \\ 
WRONG - The code will not compile, so it cannot run.

\item 2) If line 2 is uncommented, the code will fail to compile regardless of arguments passed.
 \\ 
CORRECT - This is a classic 'definite assignment' problem. The local variable \verb|x| is only initialized inside the \verb|if| block. The compiler cannot guarantee that the \verb|if| condition (\verb|args.length > 0|) will be true at runtime. Since there is a possible execution path where \verb|x| is never assigned a value, the compiler will report an error on the line \verb|System.out.println(x);| stating that 'variable x might not have been initialized'.

\item 3) If line 1 is changed to \verb|int x=0;|, the uncommented code will compile.
 \\ 
WRONG - While this statement is true (initializing \verb|x=0;| would make the code compile), it does not correctly describe the outcome of the original code as asked by the question.

\end{itemize}
\item (questionId: 102412, topic: One-Dimensional and Multi-Dimensional Arrays) \\ 
Which of these array declarations and initializations is NOT legal?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) \verb|int[] arr = new int[2];|
 \\ 
LEGAL - This correctly declares and instantiates an array of size 2, with elements defaulting to 0.

\item 1) \verb|int[] arr = new int[] {1, 2};|
 \\ 
LEGAL - This correctly uses anonymous array syntax to declare, instantiate, and initialize an array.

\item 2) \verb|int[] arr = {1, 2};|
 \\ 
LEGAL - This correctly uses the array initializer shortcut, which is valid only on the line of declaration.

\item 3) \verb|int[] arr = new int[2] {1, 2};|
 \\ 
NOT LEGAL - This is a syntax error. When using the `new` keyword with an initializer block `{}`, you cannot specify the array size in the brackets `[]`. The compiler infers the size from the initializer. This redundancy causes a compilation failure.

\end{itemize}
\item (questionId: 101311, topic: String Immutability and Operations) \\ 
What is the output of this code snippet?
\begin{verbatim}
String s1 = "1";
String s2 = s1.concat("2");
s2.concat("3");
System.out.println(s2);
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `1`
 \\ 
WRONG - The variable \verb|s2| is assigned the result of the first concatenation.

\item 1) `12`
 \\ 
CORRECT - 1. `s1` is `"1"`. 2. \verb|s2| is assigned the result of \verb|s1.concat("2")|, so \verb|s2| becomes `"12"`. 3. The line \verb|s2.concat("3")| creates a new string `"123"`, but since the result is not assigned to any variable, it is discarded. 4. The variable \verb|s2| remains unchanged from step 2, so `"12"` is printed.

\item 2) `123`
 \\ 
WRONG - This would be the output if the last line was \verb|s2 = s2.concat("3");|.

\item 3) The code does not compile.
 \\ 
WRONG - The code is syntactically correct.

\end{itemize}
\item (questionId: 102112, topic: Polymorphism and Type Casting) \\ 
What is the outcome of compiling and running this code?\n\begin{verbatim}
interface Flyable {
    void fly();
}
class Bird implements Flyable {
    public void fly() { System.out.println("Bird flying"); }
}
class Plane implements Flyable {
    public void fly() { System.out.println("Plane flying"); }
}
public class Test {
    public static void main(String[] args) {
        Flyable flyer = new Plane();
        flyer.fly();
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Bird flying
 \\ 
WRONG - The object created is an instance of \verb|Plane|, not \verb|Bird|, so the \verb|Plane|'s implementation of \verb|fly()| is called.

\item 1) Plane flying
 \\ 
RIGHT - This demonstrates polymorphism using an interface. A reference of an interface type (\verb|Flyable|) can hold an object of any class that implements that interface (\verb|Plane|). At runtime, the JVM invokes the method implementation from the actual object's class, which is \verb|Plane|.

\item 2) A compile-time error occurs.
 \\ 
WRONG - The code is valid. It's a standard use of interfaces and polymorphism.

\item 3) A `ClassCastException` is thrown.
 \\ 
WRONG - No casting is performed in this code, so a \verb|ClassCastException| cannot occur.

\end{itemize}
\item (questionId: 100611, topic: Wrapper Classes and Autoboxing/Unboxing) \\ 
Consider the following code. Which statement is true?\n\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        Long l1 = 10L;
        long l2 = 10;
        Integer i1 = 10;

        // Statement goes here
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) \verb|if (l1 == i1)| will not compile.
 \\ 
WRONG - This code will compile. When comparing wrapper types of different kinds (like \verb|Long| and \verb|Integer|) using \verb|==|, both are unboxed to their primitive types. The comparison becomes \verb|10L == 10|, which is valid.

\item 1) \verb|if (l1.equals(i1))| will return \verb|true|.
 \\ 
WRONG - The \verb|.equals()| method for wrapper types first checks if the other object is of the same type. Since \verb|i1| is an \verb|Integer| and not a \verb|Long|, \verb|l1.equals(i1)| will return \verb|false| without even checking the values.

\item 2) \verb|if (l1.equals(l2))| will not compile.
 \\ 
WRONG - This code will compile. The primitive \verb|long l2| will be autoboxed to a \verb|Long| object to be passed as an argument to the \verb|equals(Object obj)| method.

\item 3) \verb|if (l1 == l2)| will evaluate to \verb|true|.
 \\ 
CORRECT - When a comparison with \verb|==| is made between a wrapper type and a primitive type, the wrapper is **unboxed**. The statement becomes a comparison between two primitives: \verb|10L == 10L|, which evaluates to \verb|true|.

\end{itemize}
\item (questionId: 101520, topic: Classes and Objects Fundamentals) \\ 
What are the characteristics of a class that correctly follows the principle of encapsulation? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) All instance variables are declared `public` for easy access.
 \\ 
WRONG - Making instance variables \verb|public| is the opposite of good encapsulation, as it allows uncontrolled external access to the object's internal state.

\item 1) Instance variables are declared `private`.
 \\ 
CORRECT - A key principle of encapsulation is data hiding. Instance variables are typically declared \verb|private| to prevent direct access from outside the class.

\item 2) Public accessor methods (getters) and mutator methods (setters) are provided to access and modify the private instance variables.
 \\ 
CORRECT - To allow controlled access to the private data, \verb|public| methods (getters and setters) are provided. This allows the class to enforce validation or logic when its state is read or modified.

\item 3) The class cannot be instantiated.
 \\ 
WRONG - Encapsulation does not prevent instantiation; it is a principle for designing robust and maintainable objects that are meant to be instantiated.

\item 4) The internal state of the object is hidden from the outside.
 \\ 
CORRECT - This is the primary goal of encapsulation: to protect an object's internal data from arbitrary external modification, ensuring the object remains in a valid state.

\item 5) All methods are declared `static`.
 \\ 
WRONG - Encapsulation deals with the state of individual objects (instances), so it primarily involves instance methods, not \verb|static| methods which belong to the class.

\end{itemize}
\item (questionId: 101010, topic: Looping Constructs (for, while, do-while)) \\ 
What is printed by this nested loop?\n\begin{verbatim}
public class NestedLoop {
    public static void main(String[] args) {
        for (int i = 0; i < 2; i++) {
            for (int j = 2; j > 0; j--) {
                if (j == 1)
                    break;
                System.out.print(j);
            }
            System.out.print(i);
        }
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) 2021
 \\ 
CORRECT (Note: The provided answer key is incorrect). Let's trace the execution. Outer loop `i=0`: The inner loop starts with `j=2`. It prints `2`, then `j` becomes 1. When `j=1`, the `break` is hit, terminating the *inner* loop. Then, the outer loop prints `i` (which is 0). Output is now `20`. Outer loop `i=1`: The inner loop runs again, printing `2` and breaking. The outer loop then prints `i` (which is 1). The final output is `2021`.

\item 1) 202
 \\ 
WRONG - This output `202` is impossible to achieve with the given code. For the code to produce `202`, the final `System.out.print(i)` for `i=1` would have to be skipped, and there is no logic in the code to cause this. This is likely an error in the question's provided answer key.

\item 2) 21021
 \\ 
WRONG - The `break` statement prevents the inner loop from printing `1`.

\item 3) 210
 \\ 
WRONG - This would be the output if the outer loop only ran once, which is incorrect as the condition `i < 2` allows it to run for `i=0` and `i=1`.

\end{itemize}
\item (questionId: 103421, topic: Static Imports) \\ 
What is the result of attempting to compile and run the following code?
\begin{verbatim}
// File: pkg/A.java
package pkg;
public class A { 
    public static void run() { System.out.println("A"); } 
}

// File: pkg/B.java
package pkg;
public class B { 
    public static void run() { System.out.println("B"); } 
}

// File: Main.java
import static pkg.A.*;
import static pkg.B.*;

public class Main {
    public static void main(String[] args) {
        run();
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) It prints `A`.
 \\ 
WRONG - The code does not compile.

\item 1) It prints `B`.
 \\ 
WRONG - The code does not compile.

\item 2) It fails to compile due to an ambiguous call.
 \\ 
CORRECT - Both wildcard static imports, `import static pkg.A.*;` and `import static pkg.B.*;`, bring a method named `run()` into the current scope. When `run()` is called, the compiler finds two potential matching methods: `A.run()` and `B.run()`. Since it cannot decide which one to use, it raises an 'ambiguous method call' compilation error.

\item 3) It throws an exception at runtime.
 \\ 
WRONG - The ambiguity is resolved at compile time, resulting in a compilation failure.

\end{itemize}
\item (questionId: 100115, topic: Main Method and Command Line Arguments) \\ 
Consider this code:
\begin{verbatim}
public class Logic {
    public static void main(String... logic) {
        System.out.println(logic[1]);
    }
}
\end{verbatim}
What is the result of running `java Logic true false`?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) true
 \\ 
WRONG - The argument "true" is passed as the first element, so it is at index 0 (`logic[0]`).

\item 1) false
 \\ 
CORRECT - The command-line arguments are "true" and "false". They are stored in the `logic` array as `{"true", "false"}`. The code prints the element at index 1, which is the string "false".

\item 2) Compilation fails due to the parameter name `logic`.
 \\ 
WRONG - `logic` is not a reserved keyword in Java and is a perfectly valid name for a variable or parameter.

\item 3) An `ArrayIndexOutOfBoundsException` is thrown.
 \\ 
WRONG - The array has a length of 2, so indices 0 and 1 are both valid. No exception will be thrown.

\end{itemize}
\item (questionId: 100210, topic: Packages, Classpath, and JARs) \\ 
Given a source file with these two imports:
\begin{verbatim}
import java.util.Date;
import java.sql.Date;
\end{verbatim}
What is the result?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) A compilation error occurs due to the ambiguous `Date` class.
 \\ 
CORRECT - You cannot import two types with the same simple name. If you do, the compiler doesn't know which \verb|Date| to use when you refer to it in your code, leading to an 'ambiguous reference' compilation error. To resolve this, you must use the fully qualified name (e.g., \verb|java.util.Date|) for at least one of the types in your code.

\item 1) `java.util.Date` takes precedence.
 \\ 
WRONG - No import takes precedence. The conflict itself causes the compilation to fail.

\item 2) `java.sql.Date` takes precedence.
 \\ 
WRONG - No import takes precedence. The conflict itself causes the compilation to fail.

\item 3) The code compiles, but a runtime error will occur if `Date` is used.
 \\ 
WRONG - This is a compile-time error, not a runtime error. The compiler detects the ambiguity before the program can be run.

\end{itemize}
\item (questionId: 102615, topic: Generics) \\ 
What happens when you try to use `instanceof` with a generic type?\begin{verbatim}
public <T> void check(Object obj) {
    if (obj instanceof T) { // Line 2
        System.out.println("It's a T!");
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) The code works as expected.
 \\ 
WRONG - It fails to compile.

\item 1) The code compiles, but throws an exception at runtime.
 \\ 
WRONG - It is a compile-time error, not a runtime exception.

\item 2) The code fails to compile at Line 2.
 \\ 
CORRECT - This is a compilation error because of type erasure. At runtime, the type `T` is erased and replaced by its bound (in this case, `Object`). The `instanceof` operator needs to check against a specific, reifiable type at runtime, which is not possible with a generic type parameter `T`.

\item 3) The code compiles only if `T` is a final class.
 \\ 
WRONG - The rule applies regardless of whether the type is final.

\end{itemize}
\item (questionId: 102311, topic: The 'final' Keyword) \\ 
Which statement about the following code is true?\n\begin{verbatim}
final class Algorithm {
    public final void perform() {
        // ...
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) The `final` keyword on the `perform` method is required for the code to compile.
 \\ 
WRONG - The `final` keyword on the method is not required. The class would compile fine without it.

\item 1) The `final` keyword on the `perform` method is redundant.
 \\ 
RIGHT - A `final` class cannot be subclassed. By definition, this means none of its methods can ever be overridden. Therefore, declaring a method inside a `final` class as `final` is legal but redundant, as the method is already implicitly final in its behavior.

\item 2) The `final` keyword on the class `Algorithm` is redundant.
 \\ 
WRONG - The `final` keyword on the class has a distinct and important meaning: it prevents inheritance. It is not redundant.

\item 3) This code will not compile.
 \\ 
WRONG - The code is syntactically correct and compiles.

\end{itemize}
\item (questionId: 103115, topic: Try-with-Resources) \\ 
What is the output of the code?
\begin{verbatim}
class Resource implements AutoCloseable {
    public void close() { System.out.print("Close"); }
}

public class TryFinally {
    public static void main(String[] args) {
        try (Resource r = new Resource()) {
            System.out.print("Try ");
        } finally {
            System.out.print("Finally");
        }
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `Try FinallyClose`
 \\ 
WRONG - The resource is closed before the \verb|finally| block is executed.

\item 1) `Try CloseFinally`
 \\ 
CORRECT - The execution order is: 1. Resource \verb|r| is created. 2. The \verb|try| block executes, printing 'Try '. 3. The \verb|try| block completes. 4. The resource's \verb|close()| method is automatically called, printing 'Close'. 5. The \verb|finally| block executes, printing 'Finally'. The final output is `Try CloseFinally`.

\item 2) `FinallyTry Close`
 \\ 
WRONG - The \verb|try| block executes before the \verb|finally| block.

\item 3) The code does not compile.
 \\ 
WRONG - The code is syntactically correct and compiles.

\end{itemize}
\item (questionId: 101617, topic: Constructors and Initialization Blocks) \\ 
Which of the following statements about static initializer blocks are true? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) They are executed only once, when the class is first loaded by the JVM.
 \\ 
CORRECT - Static initializers are tied to the class, not an instance, and run only once per class loader.

\item 1) They can access `this` to refer to the current object.
 \\ 
WRONG - The \verb|this| keyword refers to the current instance. Static blocks are executed in a class context where no instance exists.

\item 2) A class can have multiple static initializer blocks.
 \\ 
CORRECT - A class can have multiple static blocks, and they are executed in the order they appear in the source code.

\item 3) They can access non-static instance variables of the class.
 \\ 
WRONG - Static blocks cannot access instance (non-static) variables directly, as they are not associated with any specific object.

\item 4) They are guaranteed to execute before any instance of the class is created.
 \\ 
CORRECT - Class loading and static initialization must complete before the JVM can create an instance of that class.

\item 5) They can throw checked exceptions without a `throws` clause.
 \\ 
WRONG - A static initializer block cannot throw a checked exception; this would be a compilation error. It can throw an unchecked exception, which would cause an \verb|ExceptionInInitializerError| at runtime.

\end{itemize}
\item (questionId: 102018, topic: Inheritance and Method Overriding) \\ 
Which statement best describes the difference between method overriding and method hiding?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Overriding applies to instance methods, while hiding applies to static methods. Method resolution for overriding is at runtime; for hiding, it's at compile-time.
 \\ 
CORRECT - This is the precise definition. Overriding applies to instance methods and is a runtime concept (polymorphism). Hiding applies to static methods (and fields), and the method called is determined at compile time based on the reference type.

\item 1) Overriding applies to static methods, while hiding applies to instance methods. Method resolution for overriding is at compile-time; for hiding, it's at runtime.
 \\ 
WRONG - This inverts the concepts. Overriding is for instance methods.

\item 2) Overriding involves changing the method signature, while hiding keeps it the same.
 \\ 
WRONG - This describes overloading, not overriding or hiding. Both overriding and hiding require the method signature to be the same.

\item 3) There is no difference; they are two terms for the same concept.
 \\ 
WRONG - They are distinct concepts in Java with different binding rules and behaviors.

\end{itemize}
\item (questionId: 101914, topic: Encapsulation and Access Modifiers) \\ 
What is the output of the following code?
\begin{verbatim}
class Parent {
    public String name = "Parent";
    void printName() { System.out.println(name); }
}

class Child extends Parent {
    public String name = "Child";
    void printName() { System.out.println(name); }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        System.out.println(p.name);
        p.printName();
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Parent\nChild
 \\ 
CORRECT - This question tests a crucial distinction. Variable access in Java is resolved at compile time based on the reference type, while method calls are resolved at runtime based on the actual object type. 1) \verb|p.name|: The reference \verb|p| is of type \verb|Parent|. Therefore, this expression accesses the \verb|name| field defined in the \verb|Parent| class, printing 'Parent'. Fields do not exhibit polymorphic behavior. 2) \verb|p.printName()|: This is a method call. At runtime, the JVM sees that \verb|p| points to a \verb|Child| object. Due to polymorphism (dynamic method dispatch), the overridden \verb|printName()| method from the \verb|Child| class is executed. This method prints the \verb|name| field from the \verb|Child| class's scope, which is 'Child'.

\item 1) Child\nChild
 \\ 
WRONG - This would be the output if variables were polymorphic like methods, but they are not.

\item 2) Parent\nParent
 \\ 
WRONG - This would be the output if the method call was not polymorphic.

\item 3) Child\nParent
 \\ 
WRONG - This reverses the correct results for variable access and method invocation.

\item 4) Compilation fails.
 \\ 
WRONG - The code is valid, although it demonstrates a potentially confusing practice (field hiding).

\end{itemize}
\item (questionId: 100008, topic: Java Environment and Fundamentals) \\ 
You have a file named \verb|Test.java|:
\begin{verbatim}
public class test {
    public static void main(String[] args) {
        System.out.println("Test");
    }
}
\end{verbatim}
What happens when you try to compile this file with \verb|javac Test.java|?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) It compiles successfully, creating \verb|test.class|.
 \\ 
WRONG - Compilation will fail. The generated class file would be named after the class (\verb|test.class|), but the compiler won't even get that far.

\item 1) It compiles successfully, creating \verb|Test.class|.
 \\ 
WRONG - Compilation will fail, so no \verb|.class| file will be created.

\item 2) It fails to compile because the class name \verb|test| does not match the filename \verb|Test.java|.
 \\ 
CORRECT - A fundamental rule in Java is that if a class is declared \verb|public|, the source file name must exactly match the class name, including case. Here, the filename is \verb|Test.java| but the public class is named \verb|test|, which is a mismatch. The compiler will report an error.

\item 3) It fails to compile because of a syntax error in the main method.
 \\ 
WRONG - The main method signature is syntactically correct. The error is the filename-classname mismatch, which is caught first.

\end{itemize}
\item (questionId: 102515, topic: ArrayList and Basic Collections) \\ 
What is the output?\begin{verbatim}
import java.util.ArrayList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        System.out.println(list.remove("B") + " " + list.size());
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) B 2
 \\ 
WRONG - The `remove(Object o)` method returns a `boolean`, not the element that was removed.

\item 1) true 2
 \\ 
CORRECT - The `remove(Object o)` method returns `true` if an element was removed as a result of the call, and `false` otherwise. Since "B" is in the list, it is removed, and the method returns `true`. After removal, the list's size is 2. The output is `true 2`.

\item 2) B 3
 \\ 
WRONG - The method does not return the removed element, and the size is 2 after removal.

\item 3) true 3
 \\ 
WRONG - The size is 2 after removal.

\end{itemize}
\item (questionId: 101319, topic: String Immutability and Operations) \\ 
Given `String str = "Java SE 8";`, which expressions will evaluate to `true`? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `str.startsWith("Java")`
 \\ 
CORRECT - The string `"Java SE 8"` does start with the prefix `"Java"`.

\item 1) `str.endsWith(" 8")`
 \\ 
CORRECT - The string does end with the suffix `" 8"` (note the leading space).

\item 2) `str.contains("SE")`
 \\ 
CORRECT - The string does contain the character sequence `"SE"`.

\item 3) `str.equalsIgnoreCase("java se 8")`
 \\ 
CORRECT - The \verb|equalsIgnoreCase()| method compares the content of two strings while ignoring differences in case, so this evaluates to `true`.

\end{itemize}
\item (questionId: 101709, topic: Static Members and 'this' Keyword) \\ 
What is the result of compiling and running the following code?\n\begin{verbatim}
public class StaticAccess {
    static String GREETING = "Hello";

    public static void main(String[] args) {
        StaticAccess sa = null;
        System.out.println(sa.GREETING);
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Hello
 \\ 
RIGHT - This is a classic exam trick. When a static member is accessed using an object reference, the compiler resolves the call based on the reference's *declared type*, not the object itself. The compiler effectively rewrites \verb|sa.GREETING| to \verb|StaticAccess.GREETING|. Because the object instance is never actually used for the access, it doesn't matter that the reference is \verb|null|. No \verb|NullPointerException| is thrown.

\item 1) null
 \\ 
WRONG - The static variable holds the value "Hello".

\item 2) A `NullPointerException` is thrown at runtime.
 \\ 
WRONG - No \verb|NullPointerException| is thrown because the instance itself is not dereferenced to access a static member.

\item 3) The code fails to compile.
 \\ 
WRONG - Although accessing a static member through an instance reference is discouraged, it is perfectly legal syntax.

\end{itemize}
\item (questionId: 100311, topic: Java Coding Conventions and Javadoc) \\ 
Which Javadoc tag is used to indicate that a method or class is outdated and may be removed in a future version?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `@obsolete`
 \\ 
WRONG - \verb|@obsolete| is not a standard Javadoc tag.

\item 1) `@deprecated`
 \\ 
CORRECT - The \verb|@deprecated| Javadoc tag is used to indicate that an API element (class, method, field) is no longer recommended for use and may be removed in a future version. This tag is often used in conjunction with the \verb|@Deprecated| annotation, which causes the compiler to issue a warning if the deprecated element is used.

\item 2) `@version`
 \\ 
WRONG - The \verb|@version| tag is used to specify the version of the software that the code belongs to.

\item 3) `@legacy`
 \\ 
WRONG - \verb|@legacy| is not a standard Javadoc tag.

\end{itemize}
\item (questionId: 101213, topic: Enums) \\ 
Which of the following code snippets will result in a compilation error?
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) \begin{verbatim}public enum A { X, Y; public void m() {} }\end{verbatim}
 \\ 
VALID - An enum can have methods. A semicolon is required after the last enum constant if the enum body contains other members.

\item 1) \begin{verbatim}public enum B implements java.io.Serializable { X, Y; }\end{verbatim}
 \\ 
VALID - All enums implicitly implement \verb|Serializable|. Stating it explicitly is redundant but perfectly legal.

\item 2) \begin{verbatim}public enum C { X, Y; private C() {} }\end{verbatim}
 \\ 
VALID - Enum constructors are implicitly private. Making it explicitly \verb|private| is allowed.

\item 3) \begin{verbatim}public enum D extends java.lang.Enum { X, Y; }\end{verbatim}
 \\ 
COMPILATION ERROR - This is the key restriction on enums. The compiler automatically makes every enum extend \verb|java.lang.Enum|. You are not allowed to specify this explicitly, nor can you extend any other class.

\end{itemize}
\item (questionId: 100518, topic: Type Conversion and Casting) \\ 
Which of the following lines of code require an explicit cast to compile successfully? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `long l = 10;`
 \\ 
WRONG - This is a widening conversion from an `int` literal to a `long`, so no cast is needed.

\item 1) `byte b = 10;`
 \\ 
WRONG - This is an implicit narrowing of an `int` literal to a `byte`. Since `10` is within the `byte` range, no cast is needed.

\item 2) `float f = 10.0;`
 \\ 
CORRECT - The literal `10.0` is a `double`. Assigning a `double` to a `float` is a narrowing conversion and requires an explicit cast like `(float)10.0` or using a float literal `10.0f`.

\item 3) `int i = 10L;`
 \\ 
CORRECT - The literal `10L` is a `long`. Assigning a `long` to an `int` is a narrowing conversion and requires an explicit cast like `(int)10L`.

\end{itemize}
\item (questionId: 102715, topic: Sorting and Searching Collections (Comparable, Comparator)) \\ 
Which `Comparator` static methods can be used to create a `Comparator` instance?
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `Comparator.comparing(Function)`
 \\ 
CORRECT - \verb|Comparator.comparing(Function)| is a static factory method introduced in Java 8 that takes a function extractor and returns a \verb|Comparator| that compares by that extracted key.

\item 1) `Comparator.naturalOrder()`
 \\ 
CORRECT - \verb|Comparator.naturalOrder()| is a static factory method that returns a \verb|Comparator| that uses the natural ordering of objects (i.e., calls their \verb|compareTo| method).

\item 2) `Comparator.reversed()`
 \\ 
WRONG - \verb|reversed()| is a default instance method, not a static method. It is called on an existing \verb|Comparator| instance to get a new comparator with the reverse ordering (e.g., \verb|myComp.reversed()|).

\item 3) `Comparator.thenComparing(Comparator)`
 \\ 
WRONG - \verb|thenComparing()| is a default instance method, not a static method. It is used to chain comparators for secondary, tertiary, etc. sorting criteria (e.g., \verb|comp1.thenComparing(comp2)|).

\end{itemize}
\item (questionId: 100706, topic: Variable Scope and Lifetime) \\ 
What is the result of compiling and running this class?\n\begin{verbatim}
public class ScopeTest {
    private int x = 10;

    public void process() {
        int x = 20;
        System.out.println(x);
    }

    public static void main(String[] args) {
        new ScopeTest().process();
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) 10
 \\ 
WRONG - The instance variable is 'shadowed' by the local variable.

\item 1) 20
 \\ 
CORRECT - This demonstrates variable shadowing. There are two variables named \verb|x|: the instance variable (value 10) and the local variable inside the \verb|process| method (value 20). Within the \verb|process| method, the local variable takes precedence. Therefore, \verb|System.out.println(x)| refers to the local \verb|x|, printing its value of 20.

\item 2) Compilation fails due to a duplicate variable 'x'.
 \\ 
WRONG - This is not a duplicate variable error because the variables are in different scopes (class scope vs. method scope). This is allowed in Java.

\item 3) A runtime exception is thrown.
 \\ 
WRONG - The code is valid and executes without any exceptions.

\end{itemize}
\item (questionId: 102217, topic: Abstract Classes and Interfaces) \\ 
Which statements are true about `default` methods in Java 8 interfaces? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) They must be marked with the `default` keyword.
 \\ 
CORRECT - The `default` keyword is used to signify that an interface method provides a body (a default implementation).

\item 1) They are implicitly `public`.
 \\ 
CORRECT - All methods in an interface, including `default` methods, are implicitly `public`. You cannot declare them as `protected` or `private` (until Java 9 private methods).

\item 2) A class can implement two interfaces with the same default method signature without providing its own implementation.
 \\ 
WRONG - This scenario is known as the 'diamond problem'. If a class implements two interfaces that provide a default method with the same signature, it results in a compile-time error. The class must override the method to explicitly resolve the ambiguity.

\item 3) They cannot be `static` or `final`.
 \\ 
WRONG - A `default` method is an instance method, so it cannot be `static`. It also cannot be `final` because `default` methods are designed to be overridable by implementing classes.

\end{itemize}
\item (questionId: 101419, topic: StringBuilder and StringBuffer) \\ 
Which statements are true? (Choose all that apply)
\\ \noindent Multiple correct choices. 
\begin{itemize}
\item 0) `String` objects are immutable.
 \\ 
CORRECT - `String` objects cannot be changed after creation.

\item 1) `StringBuilder` objects are mutable.
 \\ 
CORRECT - `StringBuilder` objects are designed to be changed (mutated).

\item 2) `StringBuffer` is thread-safe.
 \\ 
CORRECT - `StringBuffer` achieves thread safety by having its key methods synchronized.

\item 3) Concatenating `String` objects in a loop is generally less efficient than using `StringBuilder`.
 \\ 
CORRECT - Using the `+` operator in a loop can create many intermediate `String` objects, which is inefficient. An explicit `StringBuilder` is the preferred, more performant approach for building strings in loops.

\end{itemize}
\item (questionId: 102914, topic: Try-Catch-Finally Blocks) \\ 
What is the output of the following code?
\begin{verbatim}
public class Test {
    public static void main(String[] args) {
        String s = "";
        try {
            s += "t";
            throw new Exception();
        } catch (Exception e) {
            s += "c";
        } finally {
            s += "f";
        }
        s += "a";
        System.out.println(s);
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) `tfa`
 \\ 
WRONG - The \verb|catch| block is executed.

\item 1) `tcfa`
 \\ 
RIGHT - This is a standard execution flow. 1) \verb|try| block: `s` becomes "t". 2) An exception is thrown. 3) \verb|catch| block: The exception is caught, `s` becomes "tc". 4) \verb|finally| block: This always executes, `s` becomes "tcf". 5) The program continues after the construct, `s` becomes "tcfa". Finally, `tcfa` is printed.

\item 2) `tca`
 \\ 
WRONG - The \verb|finally| block always executes after the \verb|catch| block.

\item 3) `tcf`
 \\ 
WRONG - The code after the \verb|try-catch-finally| construct is executed because the exception was handled.

\end{itemize}
\item (questionId: 102819, topic: Exception Hierarchy and Types) \\ 
What is the result of attempting to compile and run this class?
\begin{verbatim}
public class Test {
    public void go() throws java.sql.SQLException {
        System.out.println("Going");
    }
    public static void main(String[] args) {
        Test t = new Test();
        t.go();
    }
}
\end{verbatim}
\\ \noindent Only one correct choice. 
\begin{itemize}
\item 0) Compilation fails because `main` must declare `throws java.sql.SQLException`.
 \\ 
RIGHT - The method \verb|go()| is declared with \verb|throws java.sql.SQLException|. This is a checked exception. The \verb|main| method calls \verb|t.go()| but does not handle this checked exception with a \verb|try-catch| block, nor does it declare it in its own \verb|throws| clause. This is a violation of the 'handle or declare' rule, resulting in a compilation error.

\item 1) Compilation fails for a different reason.
 \\ 
WRONG - The reason for compilation failure is specifically the unhandled checked exception.

\item 2) It compiles and prints `Going`.
 \\ 
WRONG - The code does not compile.

\item 3) It compiles but throws `java.sql.SQLException` at runtime.
 \\ 
WRONG - The code does not compile, so it cannot run to throw an exception.

\end{itemize}

\end{enumerate}

\end{document}